<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Resume Analyzer - Career Solutions for Today</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="site.css">
  <link rel="icon" type="image/png" href="https://raw.githubusercontent.com/StevenMKay/CareerSolutionsForToday/24f41fc0ba84fa65c8b2fad5155b6b32c824486e/icons/CareerIcon.png" media="(prefers-color-scheme: dark)">
  <link rel="icon" type="image/png" href="https://raw.githubusercontent.com/StevenMKay/CareerSolutionsForToday/b26be6501f1cd10eb39e1257de10c6d856ca6996/icons/Career%20Icon%20Blue.png" media="(prefers-color-scheme: light)">
  <style>
    /* Resume page specific styles */
    #star-stories-container {
    display: flex;
    flex-direction: column;
    gap: 18px;
    margin-top: 10px;
}

.star-story-card {
  background: rgba(255,255,255,0.05);
  border-radius: 12px;
  padding: 18px;
  border: 1px solid rgba(255,255,255,0.12);
  line-height: 1.5;
  color: #f5f7ff;
}

.star-story-card .star-question {
  font-weight: 600;
  color: #f1f5ff;
  margin-bottom: 8px;
}

.star-story-card .star-answer {
  color: rgba(255,255,255,0.9);
}

.star-story-card .star-segment strong,
.star-story-card .star-answer strong {
  color: #9ecbff;
}

    
    .resume-container {
      max-width: 1200px;
      margin: 110px auto 0 auto;
      padding: 30px 20px 60px 20px;
      background: linear-gradient(160deg, rgba(8,20,38,0.85), rgba(10,30,55,0.75));
      border-radius: 24px;
      box-shadow: 0 25px 70px rgba(0,0,0,0.4);
    }

    .resume-header {
      text-align: center;
      margin-bottom: 40px;
    }

    .resume-header h1 {
      color: white;
      font-size: 2.5em;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }

    .resume-header p {
      color: white;
      font-size: 1.2em;
      opacity: 0.9;
    }

    .upload-section {
      background: rgba(10,20,38,0.85);
      border-radius: 22px;
      box-shadow: 0 25px 55px rgba(0,0,0,0.45);
      padding: 40px;
      margin-bottom: 30px;
      -webkit-backdrop-filter: blur(12px);
      backdrop-filter: blur(12px);
      color: white;
      border: 1px solid rgba(66,165,245,0.25);
    }

    .upload-methods {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 30px;
      margin-bottom: 30px;
    }

    .upload-method {
      background: rgba(255,255,255,0.2);
      border-radius: 12px;
      padding: 30px;
      text-align: center;
      border: 2px dashed rgba(255,255,255,0.3);
      transition: all 0.3s ease;
      cursor: pointer;
    }

    .upload-method:hover {
      border-color: rgba(255,255,255,0.7);
      background: rgba(255,255,255,0.28);
    }
    .upload-method.success {
      border-color: #4caf50;
      background: rgba(76, 175, 80, 0.3);
      box-shadow: 0 0 20px rgba(76, 175, 80, 0.3);
    }

    .upload-method.success h3 {
      color: #4caf50;
    }

    .upload-method h3 {
      color: white;
      margin-bottom: 15px;
      font-size: 1.3em;
    }

    .file-upload {
      position: relative;
      display: inline-block;
      width: 100%;
    }

    .file-upload input[type=file] {
      position: absolute;
      opacity: 0;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }

    .upload-btn {
      background: #0b4f6c;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 16px;
      transition: background 0.3s;
      width: 100%;
    }

    .upload-btn:hover {
      background: #0a4460;
    }

    .drag-drop-area {
      border: 2px dashed rgba(255,255,255,0.4);
      border-radius: 12px;
      padding: 40px;
      text-align: center;
      margin: 20px 0;
      transition: all 0.3s ease;
      background: rgba(0,0,0,0.25);
    }

    .drag-drop-area.dragover {
      border-color: #0b4f6c;
      background: rgba(11,79,108,0.25);
    }

    .drag-drop-area.success {
      border-color: #4caf50;
      background: rgba(76, 175, 80, 0.35);
      box-shadow: 0 0 20px rgba(76, 175, 80, 0.3);
    }

    /* Enhanced drag feedback */
    .drag-drop-area.drag-active {
      border-color: #2196f3;
      background: rgba(33, 150, 243, 0.15);
      box-shadow: 0 0 30px rgba(33, 150, 243, 0.4);
      transform: scale(1.02);
      transition: all 0.2s ease;
    }

    .drag-drop-area.drag-active::before {
      content: 'üìÑ Drop your resume here!';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(33, 150, 243, 0.9);
      color: white;
      padding: 15px 25px;
      border-radius: 8px;
      font-weight: bold;
      font-size: 16px;
      z-index: 10;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
      animation: pulse 1.5s infinite;
    }

    .drag-drop-area.drag-active::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border: 3px dashed #2196f3;
      border-radius: 12px;
      animation: dashMove 2s linear infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.05); }
    }

    @keyframes dashMove {
      0% { border-dash-offset: 0; }
      100% { border-dash-offset: 20px; }
    }

    /* Body drag overlay */
    body.dragging::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(33, 150, 243, 0.1);
      z-index: 5;
      pointer-events: none;
    }

    body {
      background: linear-gradient(135deg, #071326, #0c1f33, #111c2b, #1c1f2b);
      min-height: 100vh;
      margin: 0;
      font-family: 'Segoe UI', sans-serif;
      color: white;
      line-height: 1.6;
    }

    .text-input-section {
      grid-column: 1 / -1;
    }

    .resume-textarea {
      width: 100%;
      min-height: 200px;
      padding: 15px;
      border: 1px solid rgba(255,255,255,0.3);
      border-radius: 8px;
      background: rgba(255,255,255,0.2);
      color: white;
      font-size: 14px;
      font-family: 'Segoe UI', sans-serif;
      resize: vertical;
    }

    .resume-textarea::placeholder {
      color: rgba(255,255,255,0.7);
    }

    .resume-textarea.success {
      border-color: rgba(76, 175, 80, 0.75);
      background: rgba(76, 175, 80, 0.25);
      box-shadow: 0 0 15px rgba(76, 175, 80, 0.3);
    }

    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      border: 0;
    }

    .section-title {
      color: #e3f2fd;
      text-align: center;
      margin-bottom: 30px;
      font-size: 2em;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-weight: 700;
      position: relative;
    }

    .section-title::after {
      content: '';
      display: block;
      width: 90px;
      height: 4px;
      border-radius: 999px;
      margin: 14px auto 0;
      background: linear-gradient(90deg, #64b5f6, #42a5f5, #1e88e5);
      box-shadow: 0 0 12px rgba(66,165,245,0.5);
    }

    .section-title.tight {
      margin-bottom: 20px;
    }

    .section-subtext {
      text-align: center;
      margin-bottom: 30px;
      color: rgba(255,255,255,0.85);
    }

    .collapsible {
      text-align: left;
    }

    .collapsible-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .collapsible-header p {
      margin: 6px 0 0;
      color: rgba(255,255,255,0.8);
    }

    .collapsible-toggle {
      margin-top: 10px;
      background: rgba(255,255,255,0.15);
      border: 1px solid rgba(255,255,255,0.3);
      color: white;
      padding: 10px 16px;
      border-radius: 8px;
      cursor: pointer;
      transition: background 0.3s ease;
    }

    .collapsible-toggle:hover {
      background: rgba(255,255,255,0.25);
    }

    .collapsible-content {
      display: none;
      margin-top: 15px;
    }

    .collapsible.open .collapsible-content {
      display: block;
    }

    .collapsible-content[hidden] {
      display: none !important;
    }

    .resume-textarea.collapsible-target {
      min-height: 200px;
    }

    .job-description-textarea {
      min-height: 150px;
    }

    .analyze-btn {
      background: linear-gradient(45deg, #0b4f6c, #1976d2);
      color: white;
      border: none;
      padding: 15px 30px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      margin-top: 20px;
      transition: all 0.3s ease;
      display: block;
      margin: 20px auto 0 auto;
    }

    .analyze-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(11,79,108,0.4);
    }

    .analyze-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .job-link-tip {
      margin-top: 10px;
      font-size: 0.95em;
      color: rgba(255,255,255,0.85);
    }

    .job-link-tip strong {
      color: #64b5f6;
    }

    .job-link-input {
      width: 100%;
      margin-top: 12px;
      padding: 12px 14px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.3);
      background: rgba(255,255,255,0.2);
      color: white;
      font-size: 0.95em;
    }

    .job-link-input::placeholder {
      color: rgba(255,255,255,0.7);
    }

    .job-link-status {
      margin-top: 8px;
      font-size: 0.9em;
      min-height: 18px;
      color: rgba(255,255,255,0.85);
    }

    .job-link-status.success {
      color: #81c784;
    }

    .job-link-status.info {
      color: #64b5f6;
    }

    .job-link-status.error {
      color: #ff8a80;
    }

    /* Dev reminder: never default new panels to opacity: 0 unless they have matching show logic */
    .feedback-section {
      background: rgba(5,12,24,0.92);
      border-radius: 22px;
      box-shadow: 0 30px 60px rgba(0,0,0,0.45);
      border: 1px solid rgba(66,165,245,0.25);
      padding: 40px;
      margin-bottom: 30px;
      -webkit-backdrop-filter: blur(12px);
      backdrop-filter: blur(12px);
      color: white;
      display: none;
    }

    .feedback-section.show {
      display: block;
      animation: fadeIn 0.5s ease-in;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .feedback-category {
      margin-bottom: 25px;
      padding: 22px;
      background: rgba(7,17,32,0.88);
      border-radius: 14px;
      border: 1px solid rgba(88,142,255,0.32);
      border-left: 6px solid #1976d2;
      box-shadow: 0 18px 38px rgba(0,0,0,0.45);
    }

    .score-explanation {
      margin: 8px 0 12px;
      font-style: italic;
      color: rgba(255,255,255,0.85);
    }

    .positive-examples {
      margin-bottom: 12px;
    }

    .positive-examples strong {
      display: block;
      margin-bottom: 6px;
      color: rgba(255,255,255,0.95);
    }

    .positive-examples ul {
      margin: 0;
      padding-left: 20px;
      color: rgba(255,255,255,0.92);
    }

    .feedback-category h3 {
      color: white;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .feedback-category.good {
      border-left-color: #4caf50;
    }

    .feedback-category.warning {
      border-left-color: #ff9800;
    }

    .feedback-category.critical {
      border-left-color: #f44336;
    }

    .status-icon {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: inline-block;
    }

    .status-icon.good { background: #4caf50; }
    .status-icon.warning { background: #ff9800; }
    .status-icon.critical { background: #f44336; }

    .overall-score-card {
      text-align: center;
      margin-bottom: 30px;
      padding: 24px;
      border-radius: 18px;
      background: rgba(7,17,34,0.9);
      border: 1px solid rgba(134,192,255,0.3);
      box-shadow: 0 18px 38px rgba(0,0,0,0.45);
    }

    .overall-score-title {
      color: white;
      font-size: 2em;
      margin-bottom: 10px;
    }

    .job-match-indicator {
      color: #7cf29d;
      margin-bottom: 10px;
    }

    .score-adjustment-card {
      border-left-width: 6px;
      border-left-color: #ff9800;
    }
    .score-adjustment-card.critical {
      border-left-color: #f44336;
    }
    .score-adjustment-card .suggestions-list {
      margin-top: 6px;
    }

    .score-bar {
      width: 100%;
      background: rgba(255,255,255,0.12);
      border-radius: 10px;
      height: 20px;
      margin: 0 auto;
      max-width: 400px;
      overflow: hidden;
    }

    .score-bar-fill {
      height: 100%;
      border-radius: 10px;
      background: linear-gradient(90deg, #7cf29d, #42a5f5);
      width: 0;
      transition: width 0.5s ease;
    }

    #feedbackContent > * + * {
      border-top: 1px solid rgba(255,255,255,0.22);
      margin-top: 30px;
      padding-top: 30px;
    }

    .category-feedback {
      margin-bottom: 15px;
      color: rgba(255,255,255,0.85);
    }

    .suggestions-list {
      margin-top: 10px;
      padding-left: 20px;
    }

    .collapsible-panel {
      position: relative;
    }

    .collapsible-panel-toggle {
      width: 100%;
      background: transparent;
      border: none;
      color: inherit;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      cursor: pointer;
      padding: 0;
      text-align: left;
    }

    .collapsible-panel-title {
      font-size: 1.1em;
      font-weight: 600;
      color: white;
    }

    .collapsible-panel-icon {
      display: inline-flex;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,0.35);
      align-items: center;
      justify-content: center;
      font-size: 1.2em;
      transition: transform 0.25s ease;
    }

    .collapsible-panel:not(.open) .collapsible-panel-icon {
      transform: rotate(-90deg);
    }

    .collapsible-panel-body {
      margin-top: 18px;
    }

    .company-insights,
    .extra-insights,
    .keyword-section {
      margin-top: 30px;
      padding: 28px;
      border-radius: 18px;
      background: rgba(9,25,46,0.9);
      border: 1px solid rgba(134,192,255,0.35);
      box-shadow: 0 22px 45px rgba(3,8,16,0.55);
      opacity: 1 !important;
      transform: none !important;
      transition: none !important;
    }

    .company-insights h3, .extra-insights h3 {
      margin-top: 0;
      margin-bottom: 15px;
      color: white;
    }

    .company-insight-card {
      margin-bottom: 15px;
      padding: 15px;
      border-radius: 12px;
      background: rgba(11,79,108,0.35);
      border-left: 4px solid #42a5f5;
    }

    .company-insight-card p {
      margin: 8px 0;
      color: rgba(255,255,255,0.9);
    }

    .insight-action {
      margin-top: 4px;
    }

    .insight-action strong {
      color: #bbdefb;
    }

    .insight-link {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.9em;
      margin-top: 8px;
      color: #8ec5ff;
      text-decoration: none;
    }

    .insight-link:hover {
      text-decoration: underline;
    }

    .extra-insight-card {
      margin-bottom: 15px;
      padding: 15px;
      border-radius: 12px;
      background: rgba(33,150,243,0.12);
      border-left: 4px solid #64b5f6;
    }

    .extra-insight-card.status-good { border-left-color: #81d4fa; }
    .extra-insight-card.status-warning { border-left-color: #4fc3f7; }
    .extra-insight-card.status-critical { border-left-color: #29b6f6; }

    .extra-insight-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }

    .extra-insight-header h4 {
      margin: 0;
      color: white;
    }

    .insight-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.85em;
      padding: 4px 12px;
      border-radius: 999px;
      background: rgba(255,255,255,0.25);
      margin-bottom: 8px;
    }

    .status-dot {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 2px solid rgba(255,255,255,0.35);
      margin-bottom: 10px;
    }

    .status-dot.good { background: #a5d6ff; }
    .status-dot.warning { background: #8ec5ff; }
    .status-dot.critical { background: #5da7ff; }

    .extra-insight-card ul {
      margin: 10px 0 0 20px;
    }

    .keyword-section h3 {
      margin-top: 0;
      margin-bottom: 10px;
      color: white;
    }

    .keyword-section p {
      margin: 0 0 18px 0;
      color: rgba(255,255,255,0.85);
    }

    .keyword-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 18px;
    }

    .legend-item {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 14px;
      border-radius: 999px;
      font-size: 0.9em;
      background: rgba(9,22,41,0.85);
      border: 1px solid rgba(134,192,255,0.35);
    }

    .legend-item.match {
      border-color: rgba(124,242,157,0.8);
      background: rgba(76,175,80,0.25);
    }

    .legend-item.missing {
      border-color: rgba(255,152,0,0.7);
      background: rgba(255,152,0,0.22);
    }

    .keyword-list {
      list-style: none;
      padding: 0;
      margin: 0;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 15px;
    }

    .keyword-item {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 15px;
      border-radius: 12px;
      background: rgba(7,17,34,0.88);
      border: 1px solid rgba(134,192,255,0.28);
    }

    .keyword-item.match {
      border-color: rgba(124,242,157,0.7);
      background: rgba(31,76,52,0.9);
    }

    .keyword-item.missing {
      border-color: rgba(255,152,0,0.6);
      background: rgba(76,45,13,0.85);
    }

    .keyword-pill {
      font-weight: 600;
      color: white;
      font-size: 1.05em;
    }

    .keyword-count {
      font-size: 0.9em;
      color: rgba(255,255,255,0.75);
    }

    .download-section {
      background: rgba(8,18,34,0.9);
      border-radius: 22px;
      box-shadow: 0 25px 55px rgba(0,0,0,0.45);
      padding: 40px;
      -webkit-backdrop-filter: blur(12px);
      backdrop-filter: blur(12px);
      color: white;
      border: 1px solid rgba(66,165,245,0.25);
    }

    .templates-cta {
      text-align: center;
      margin-top: 25px;
    }

    .template-link {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      background: linear-gradient(45deg, #0b4f6c, #42a5f5);
      color: white;
      padding: 14px 28px;
      border-radius: 999px;
      text-decoration: none;
      font-weight: 600;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .template-link:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 18px rgba(11,79,108,0.35);
    }

    .progress-bar {
      width: 100%;
      height: 4px;
      background: rgba(255,255,255,0.2);
      border-radius: 2px;
      margin: 20px 0;
      overflow: hidden;
      display: none;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #0b4f6c, #1976d2);
      width: 0%;
      transition: width 0.3s ease;
    }

    @media (max-width: 768px) {
      .upload-methods {
        grid-template-columns: 1fr;
        gap: 20px;
      }

      .resume-container {
        padding: 20px 15px;
      }

      .upload-section, .feedback-section, .download-section {
        padding: 25px;
      }

      .resume-header h1 {
        font-size: 2em;
      }

      .text-input-section {
        grid-column: 1 / -1;
      }
    }
    .story-builder-wrapper {
      margin-top: 25px;
    }

    .story-builder-intro {
      margin: 4px 0 16px;
      color: rgba(255,255,255,0.75);
      line-height: 1.5;
    }

    .star-story-stack {
      display: grid;
      gap: 16px;
      margin-top: 12px;
    }

    .story-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 18px;
      margin-top: 24px;
      align-items: stretch;
    }

    .story-card {
      background: #1b2233;
      border: 1px solid #2d3547;
      border-radius: 12px;
      padding: 18px;
      min-height: 180px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      box-shadow: 0 15px 35px rgba(5,8,20,0.45);
    }

    .story-card h4 {
      margin: 0;
      font-size: 1rem;
      color: #f5f7ff;
    }

    .story-card-text {
      color: rgba(255,255,255,0.85);
      line-height: 1.5;
      margin: 0;
    }

    .story-pill-tray {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: flex-start;
    }

    .story-card ul {
      padding-left: 18px;
      margin: 8px 0 0;
      line-height: 1.45;
    }

    @media (max-width: 900px) {
      .story-grid {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 600px) {
      .star-story-stack {
        margin-top: 8px;
      }

      .story-card {
        padding: 16px;
      }
    }

    #starStoryList {
      list-style: none;
      padding-left: 0;
      margin: 12px 0 0;
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    #starStoryList li {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 12px;
      padding: 16px 18px;
    }

    .star-question-intro {
      margin: 6px 0 0;
      font-size: 0.9em;
      color: rgba(255,255,255,0.72);
    }

    .star-question {
      font-weight: 600;
      color: #f1f5ff;
      margin-bottom: 6px;
    }

    .star-answer {
      color: rgba(255,255,255,0.86);
      line-height: 1.5;
      margin-top: 10px;
    }

    .star-answer strong {
      color: #9ecbff;
    }

    .star-narrative {
      display: inline;
    }

    .star-segment {
      display: inline-block;
      margin-right: 10px;
      margin-top: 4px;
    }

    .star-segment strong {
      color: #b9d6ff;
      margin-right: 4px;
    }

    .star-raw-answer {
      display: inline;
    }

    .star-empty {
      color: rgba(255,255,255,0.65);
      font-style: italic;
    }

    .star-steps {
      list-style: none;
      padding-left: 0;
      margin: 6px 0 0;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .star-steps li {
      font-size: 0.92em;
      color: rgba(255,255,255,0.85);
      line-height: 1.45;
    }

    .star-steps li p {
      margin: 4px 0 0 0;
      padding-left: 8px;
      border-left: 2px solid rgba(79, 146, 255, 0.3);
    }

    .star-steps strong {
      color: #b9d6ff;
      font-weight: 600;
    }

    .star-bullet-list {
      list-style: disc;
      padding-left: 24px;
      margin: 4px 0 0;
    }

    .star-bullet-list li {
      font-size: 0.9em;
      color: rgba(255,255,255,0.8);
      line-height: 1.5;
      margin-bottom: 4px;
    }

    .story-pill {
      display: inline-block;
      background: rgba(79, 146, 255, 0.25);
      border-radius: 999px;
      padding: 4px 10px;
      margin: 4px;
      font-size: 13px;
    }
  </style>
</head>

<body>
  <nav class="navbar">
    <div class="nav-logo">Career Solutions for Today</div>
    <ul class="nav-links" id="navLinks">
      <li><a href="index.html">Home</a></li>
      <li><a href="Learn.html" class="learn-underline">Learning Resources</a></li>
      <!--
      <li class="dropdown" id="toolsDropdown">
        <span class="dropdown-toggle" id="toolsToggle">Tools</span>
        <ul class="dropdown-menu" id="toolsDropdownMenu">
          <li><a href="businesscase.html" target="_blank">Business Case Calculator</a></li>
          <li><a href="amortization.html" target="_blank">Amortization Calculator</a></li>
          <li><a href="Signature Builder.html" target="_blank">Email Signature Builder</a></li>
          <li><a href="Excel.html" target="_blank">Excel Simulations</a></li>
          <li><a href="shortcuts.html" target="_blank">Shortcuts</a></li>
        </ul>
      </li>
      -->
      <!-- <li><a href="practice.html">Practice</a></li> -->
      <li><a href="codeplayground.html">Code Playground</a></li>
      <li><a href="products.html">Products</a></li>
      <li><a href="contact-form.html">Contact Me</a></li>
      <li><a href="AboutMe.html" class="about-underline">About Me</a></li>
    </ul>
    <div class="hamburger" onclick="document.querySelector('.nav-links').classList.toggle('active')">
      <div></div>
      <div></div>
      <div></div>
    </div>
  </nav>

  <div class="resume-container">
    <div class="resume-header">
      <h1>AI-Powered Resume Analyzer</h1>
      <p>Upload your resume and get instant feedback to land your dream job</p>
    </div>

    <div class="upload-section">
      <h2 class="section-title">Upload Your Resume</h2>
      
      <div class="upload-methods">
        <div class="upload-method">
          <h3>üìÑ Upload File</h3>
          <p>Upload your resume in PDF, DOC, or DOCX format</p>
          <div class="file-upload">
            <label class="visually-hidden" for="fileInput">Select your resume file to upload</label>
            <input type="file" id="fileInput" accept=".pdf,.doc,.docx" />
            <button class="upload-btn">Choose File</button>
          </div>
        </div>

        <div class="upload-method" id="dragDropArea">
          <h3>üéØ Drag & Drop</h3>
          <p>Drag your resume file here for quick upload</p>
          <div class="drag-drop-area">
            <p>Drop your file here</p>
          </div>
        </div>

        <div class="text-input-section upload-method collapsible" id="resumeTextSection">
          <div class="collapsible-header">
            <div>
              <h3>üìù Copy & Paste Resume</h3>
              <p>Paste your resume text directly into the box below</p>
            </div>
            <button type="button" class="collapsible-toggle" data-target="resumeTextContent" aria-expanded="false">
              Show Text Input
            </button>
          </div>
          <div class="collapsible-content" id="resumeTextContent" hidden>
            <textarea 
              class="resume-textarea collapsible-target" 
              id="resumeText" 
              placeholder="Paste your resume text here...&#10;&#10;Include all sections: Contact info, Summary, Experience, Education, Skills, etc."
            ></textarea>
          </div>
        </div>

        <div class="text-input-section upload-method">
          <h3>üéØ Job Description or Link (Optional)</h3>
          <p>Paste the job description text or drop in a LinkedIn job URL for targeted feedback</p>
          <textarea 
            class="resume-textarea job-description-textarea" 
            id="jobDescriptionText" 
            placeholder="Paste the job description here (optional)...&#10;&#10;Include: Job title, requirements, responsibilities, preferred skills, etc.&#10;or paste a full LinkedIn job link (https://www.linkedin.com/jobs/...) and we'll pull the posting automatically."
          ></textarea>
          <input 
            type="url" 
            class="job-link-input" 
            id="jobDescriptionLink" 
            placeholder="Paste LinkedIn job URL (optional)..." 
            inputmode="url"
          />
          <div class="job-link-status" id="jobLinkStatus" aria-live="polite"></div>
          <p class="job-link-tip">Tip: You can paste a <strong>LinkedIn job posting URL</strong> and the analyzer will fetch the description for you.</p>
        </div>
      </div>

      <div class="progress-bar" id="progressBar">
        <div class="progress-fill" id="progressFill"></div>
      </div>

      <button class="analyze-btn" id="analyzeBtn" disabled>
        üîç Analyze My Resume
      </button>
    </div>

    <div class="feedback-section" id="feedbackSection">
      <h2 class="section-title">Resume Analysis Results</h2>
      <div id="feedbackContent"></div>
      <div id="storyBuilderSection" class="story-builder-wrapper" style="display:none;">
        <section class="story-builder-panel collapsible-panel" data-collapsible-section>
          <button class="collapsible-panel-toggle" type="button" aria-expanded="false" aria-controls="interviewStoryBuilderBody">
            <span class="collapsible-panel-title">Interview Story Builder</span>
            <span class="collapsible-panel-icon" aria-hidden="true">‚ñæ</span>
          </button>
          <div class="collapsible-panel-body" id="interviewStoryBuilderBody" hidden>
            <p class="story-builder-intro">Use these AI-built talking points to answer behavioral interviews on the spot. Add metrics to your resume for even stronger stories.</p>
            <div class="star-story-stack" id="star-stories-container"></div>
            <div class="story-grid" aria-live="polite">
              <article class="story-card">
                <h4>Tell me about yourself</h4>
                <p id="tellMeStory" class="story-card-text">We will outline your 60-second opener once the analysis finishes.</p>
              </article>
              <article class="story-card">
                <h4>Strength pillars recruiters will test</h4>
                <div id="strengthPills" class="story-pill-tray">
                  <p class="story-card-text">Add quantified accomplishments so we can highlight your biggest proof points.</p>
                </div>
              </article>
              <article class="story-card">
                <h4>Weakness mitigation plan</h4>
                <p id="weaknessPlan" class="story-card-text">We will flag the most likely follow-up question and how to de-risk it.</p>
              </article>
              <article class="story-card">
                <h4>30-second elevator pitch</h4>
                <p id="elevatorPitch" class="story-card-text">Expect a concise pitch that blends your resume signals with the role summary.</p>
              </article>
            </div>
          </div>
        </section>
      </div>
    </div>

    <div class="download-section" id="downloadSection">
      <h2 class="section-title tight">Continue With Premium Templates</h2>
      <p class="section-subtext">Turn these insights into a recruiter-ready document using the curated resume templates inside Career Members.</p>

      <div class="templates-cta">
        <a class="template-link" href="CareerMembers.html#resume-templates" target="_blank" rel="noopener">
          Visit Career Members Resume Templates
        </a>
      </div>
    </div>
  </div>

  <script src="js/backgrounds.js"></script>
  <script src="js/universalSidebar.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.4.2/mammoth.browser.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  
  <script>
    let resumeData = null;
    let analysisResults = null;

    /**
     * LLM integration configuration
     * 1. Point `BACKEND_URL` to the secured API route that calls your LLM provider.
     * 2. Keep API keys/server-side logic out of this file‚Äîonly send plain resume/job description text from the browser.
     */
    const CONFIG = {
      BACKEND_URL: 'https://resume-analyzer-backend-stevens-projects-4a20c66c.vercel.app/api/analyze',
      FALLBACK_TO_MOCK_ON_FAILURE: false
    };

    const KEYWORD_STOP_WORDS = new Set([
      'the','and','for','with','your','you','our','are','this','that','from','have','has','will','their','they',
      'job','description','role','responsibilities','requirements','skills','ability','work','team','per','such',
      'experience','strong','must','should','about','into','within','across','while','into','including','more',
      'than','who','what','where','when','which','why','how','via','using','use','can','able','need','needed',
      'preferred','plus','bonus','an','a','of','in','to','by','as','on','at','is','be','it','or'
    ]);

    const GENERIC_JOB_TERMS = new Set([
      'benefits','benefit','compensation','salary','salaries','bonus','bonuses','insurance','medical',
      'dental','vision','pto','vacation','holidays','401k','retirement','paid','payment','hourly','hours',
      'company','companies','organization','organizations','org','corporate','corporation','enterprise',
      'enterprises','department','departments','business','businesses','employer','employers','culture',
      'mission','values','new','end'
    ]);

    const ALLOWED_SHORT_TOKENS = new Set(['ai','ml','hr','ui','ux','qa','sql','sap','api','aws','erp','crm','etl','bi','ads']);

    const JOB_SECTION_KEYWORDS = [
      'responsibilities','responsibility','responsible for','requirements','required','qualifications','qualification',
      'what you will do','what you\'ll do','about the role','about you','who you are','day to day','day-to-day',
      'duties','expectations','must have','nice to have','preferred qualifications','skills','experience'
    ];

    const JOB_CONTEXT_LANGUAGE_PATTERNS = [
      /job description/gi,
      /job posting/gi,
      /this role/gi,
      /the role/gi,
      /role requirements?/gi,
      /position requirements?/gi,
      /hiring manager/gi,
      /align with the role/gi,
      /\bJD\b/gi
    ];

    const CLIENT_CRITICAL_KEYWORD_LIBRARY = [
      { phrase: 'Program Management', hints: ['program management','program manager'] },
      { phrase: 'Project Management', hints: ['project management','project manager'] },
      { phrase: 'Cross-functional leadership', hints: ['cross-functional','cross functional'] },
      { phrase: 'Process improvement', hints: ['process improvement','process optimization'] },
      { phrase: 'Operational excellence', hints: ['operational excellence','operational efficiency'] },
      { phrase: 'Data-driven decision making', hints: ['data-driven','data driven','metrics'] },
      { phrase: 'Success metrics & KPIs', hints: ['kpi','success metrics'] },
      { phrase: 'Resource planning', hints: ['resource planning','resource allocation'] },
      { phrase: 'Strategic initiatives', hints: ['strategic initiative','strategic program'] },
      { phrase: 'End-to-end program delivery', hints: ['end-to-end','end to end'] },
      { phrase: 'Healthcare operations', hints: ['healthcare','care delivery'] },
      { phrase: 'Clinical programs / care pathways', hints: ['clinical program','care pathway'] },
      { phrase: 'Stakeholder management', hints: ['stakeholder management','stakeholder alignment'] },
      { phrase: 'Continuous improvement', hints: ['continuous improvement'] },
      { phrase: 'Population health / at-risk populations', hints: ['population health','at-risk'] }
    ];

    const CLIENT_FALLBACK_CRITICAL_KEYWORDS = [
      'Program Management',
      'Project Management',
      'Cross-functional leadership',
      'Process improvement',
      'Operational excellence',
      'Data-driven decision making',
      'Success metrics & KPIs',
      'Resource planning',
      'Strategic initiatives',
      'End-to-end program delivery',
      'Healthcare operations',
      'Clinical programs / care pathways',
      'Stakeholder management',
      'Continuous improvement',
      'Population health / at-risk populations'
    ];

    const JOB_LINK_PREFETCH_DELAY = 650;
    let jobLinkPrefetchTimeout = null;
    let jobLinkPrefetchController = null;
    let lastPrefetchedJobUrl = '';
    let lastPrefetchedJobDescription = '';

    if (window.pdfjsLib) {
      pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    }

    // üí∞ Usage tracking (hidden but still functional)
    const MONTHLY_BUDGET_LIMIT = 20.00;
    const COST_PER_ANALYSIS = 0.01;

    function getJobDescriptionValue() {
      const jobDescriptionInput = document.getElementById('jobDescriptionText');
      return jobDescriptionInput ? jobDescriptionInput.value.trim() : '';
    }
    
    // Hidden usage tracking functions (no UI display)
    function getUsageData() {
      const currentMonth = new Date().toISOString().slice(0, 7);
      const stored = localStorage.getItem('resumeAnalyzer_usage');
      
      if (!stored) {
        return { month: currentMonth, count: 0, cost: 0 };
      }
      
      const data = JSON.parse(stored);
      
      if (data.month !== currentMonth) {
        return { month: currentMonth, count: 0, cost: 0 };
      }
      
      return data;
    }
    
    function updateUsageData() {
      const currentMonth = new Date().toISOString().slice(0, 7);
      const usage = getUsageData();
      
      usage.month = currentMonth;
      usage.count += 1;
      usage.cost += COST_PER_ANALYSIS;
      
      localStorage.setItem('resumeAnalyzer_usage', JSON.stringify(usage));
      
      // Log usage for admin tracking (hidden from users)
      console.log(`Usage Update: ${usage.count} analyses, $${usage.cost.toFixed(2)} cost this month`);
      
      return usage;
    }
    
    function checkBudgetLimit() {
      const usage = getUsageData();
      return usage.cost < MONTHLY_BUDGET_LIMIT;
    }

    // File upload handling
    document.getElementById('fileInput').addEventListener('change', handleFileUpload);
    
    // Drag and drop handling
    const dragDropArea = document.getElementById('dragDropArea');
    const dragDropContainer = dragDropArea.querySelector('.drag-drop-area');
    
    // Enhanced drag and drop event listeners
    dragDropArea.addEventListener('dragover', handleDragOver);
    dragDropArea.addEventListener('drop', handleFileDrop);
    dragDropArea.addEventListener('dragleave', handleDragLeave);
    dragDropArea.addEventListener('dragenter', handleDragEnter);

    // Global drag detection for full-page overlay
    let dragCounter = 0;
    document.addEventListener('dragenter', function(e) {
      e.preventDefault();
      dragCounter++;
      if (dragCounter === 1) {
        document.body.classList.add('dragging');
      }
    });

    document.addEventListener('dragleave', function(e) {
      e.preventDefault();
      dragCounter--;
      if (dragCounter === 0) {
        document.body.classList.remove('dragging');
      }
    });

    document.addEventListener('drop', function(e) {
      e.preventDefault();
      dragCounter = 0;
      document.body.classList.remove('dragging');
    });

    // Text input handling
    document.getElementById('resumeText').addEventListener('input', handleTextInput);
    document.getElementById('resumeText').addEventListener('paste', handleTextPaste);

    const jobDescriptionTextArea = document.getElementById('jobDescriptionText');
    if (jobDescriptionTextArea) {
      jobDescriptionTextArea.addEventListener('input', handleJobDescriptionTextareaInput);
    }

    const jobDescriptionLinkInput = document.getElementById('jobDescriptionLink');
    if (jobDescriptionLinkInput) {
      jobDescriptionLinkInput.addEventListener('input', handleJobLinkInput);
      jobDescriptionLinkInput.addEventListener('blur', handleJobLinkBlur);
      jobDescriptionLinkInput.addEventListener('paste', handleJobLinkPaste);
    }

    // Analyze button
    document.getElementById('analyzeBtn').addEventListener('click', analyzeResume);

    // Utility function to clear success states
    function clearSuccessStates(except = []) {
      if (!except.includes('file')) {
        // Clear file upload success
        const fileUploadMethod = document.querySelector('.upload-method:first-child');
        fileUploadMethod.classList.remove('success');
      }
      
      if (!except.includes('dragdrop')) {
        // Clear drag-drop success
        const dragDropMethod = document.getElementById('dragDropArea');
        const dragDropContainer = dragDropMethod.querySelector('.drag-drop-area');
        dragDropMethod.classList.remove('success');
        dragDropContainer.classList.remove('success');
      }
      
      if (!except.includes('textarea')) {
        // Clear textarea success
        const textareas = document.querySelectorAll('.resume-textarea');
        textareas.forEach(textarea => {
          textarea.classList.remove('success');
          textarea.closest('.upload-method').classList.remove('success');
        });
      }
    }

    // Handle paste events in text areas
    function handleTextPaste(event) {
      const textarea = event.target;
      
      // Use setTimeout to get the pasted content after it's been inserted
      setTimeout(() => {
        const text = textarea.value.trim();
        if (text.length > 50) {
          // Clear other success states when pasting
          clearSuccessStates(['textarea']);
          
          // Add success state to this textarea and its parent
          textarea.classList.add('success');
          textarea.closest('.upload-method').classList.add('success');
          
          resumeData = { type: 'text', content: text };
          document.getElementById('analyzeBtn').disabled = false;
        }
      }, 10);
    }

    function handleFileUpload(event) {
      const file = event.target.files[0];
      if (file) {
        // Clear any existing success states
        clearSuccessStates();
        
        // Add success state to the file upload method
        const fileUploadMethod = document.querySelector('.upload-method:first-child');
        fileUploadMethod.classList.add('success');
        
        processFile(file);
      }
    }

    function handleDragEnter(event) {
      event.preventDefault();
      event.stopPropagation();
      dragDropContainer.classList.add('drag-active');
    }

    function handleDragOver(event) {
      event.preventDefault();
      event.stopPropagation();
      dragDropContainer.classList.add('drag-active');
    }

    function handleDragLeave(event) {
      event.preventDefault();
      event.stopPropagation();
      
      // Only remove drag-active if we're leaving the actual drag area
      if (!dragDropArea.contains(event.relatedTarget)) {
        dragDropContainer.classList.remove('drag-active');
      }
    }

    function handleFileDrop(event) {
      event.preventDefault();
      event.stopPropagation();
      
      // Remove all drag states
      dragDropContainer.classList.remove('dragover', 'drag-active');
      document.body.classList.remove('dragging');
      dragCounter = 0;
      
      const files = event.dataTransfer.files;
      if (files.length > 0) {
        // Clear any existing success states
        clearSuccessStates();
        
        // Add success state to drag-drop area
        dragDropArea.classList.add('success');
        dragDropContainer.classList.add('success');
        
        processFile(files[0]);
      }
    }

    function handleTextInput(event) {
      const text = event.target.value.trim();
      const textarea = event.target;
      
      if (text.length > 50) {
        // Clear other success states when typing in text area
        clearSuccessStates(['textarea']);
        
        // Add success state to this textarea and its parent
        textarea.classList.add('success');
        textarea.closest('.upload-method').classList.add('success');
        
        resumeData = { type: 'text', content: text };
        document.getElementById('analyzeBtn').disabled = false;
      } else {
        // Remove success state if text is too short
        textarea.classList.remove('success');
        textarea.closest('.upload-method').classList.remove('success');
        document.getElementById('analyzeBtn').disabled = true;
      }
    }

    async function processFile(file) {
      const allowedTypes = ['application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'];
      
      if (!allowedTypes.includes(file.type)) {
        alert('Please upload a PDF, DOC, or DOCX file.');
        return;
      }

      // Show progress bar
      const progressBar = document.getElementById('progressBar');
      const progressFill = document.getElementById('progressFill');
      progressBar.style.display = 'block';

      try {
        let extractedText = '';

        if (file.type === 'application/pdf') {
          extractedText = await extractTextFromPDF(file);
        } else if (file.type.includes('word') || file.type.includes('document')) {
          extractedText = await extractTextFromWord(file);
        }

        // Simulate progress
        let progress = 0;
        const interval = setInterval(() => {
          progress += 10;
          progressFill.style.width = progress + '%';
          
          if (progress >= 100) {
            clearInterval(interval);
            setTimeout(() => {
              progressBar.style.display = 'none';
              progressFill.style.width = '0%';
              
              if (extractedText.trim().length > 50) {
                resumeData = { type: 'file', content: extractedText, filename: file.name };
                document.getElementById('analyzeBtn').disabled = false;
                alert(`File "${file.name}" processed successfully! ${extractedText.length} characters extracted. Click "Analyze My Resume" to continue.`);
              } else {
                alert('Could not extract enough text from the file. Please try a different file or use copy/paste method.');
              }
            }, 500);
          }
        }, 200);

      } catch (error) {
        progressBar.style.display = 'none';
        alert('Error processing file: ' + error.message);
      }
    }

    async function extractTextFromPDF(file) {
      if (!window.pdfjsLib) {
        throw new Error('PDF parser not available. Please refresh and try again.');
      }

      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      let text = '';

      for (let pageNumber = 1; pageNumber <= pdf.numPages; pageNumber++) {
        const page = await pdf.getPage(pageNumber);
        const content = await page.getTextContent();
        const pageText = content.items
          .map(item => ('str' in item ? item.str : item.text) || '')
          .join(' ');
        text += pageText + '\n';
      }

      return text.trim();
    }

    async function extractTextFromWord(file) {
      const arrayBuffer = await file.arrayBuffer();
      const result = await mammoth.extractRawText({ arrayBuffer });
      let combinedText = typeof result.value === 'string' ? result.value : '';

      if (window.JSZip) {
        try {
          const zip = await JSZip.loadAsync(arrayBuffer);
          const headerFooterPaths = [
            'word/header1.xml','word/header2.xml','word/header3.xml',
            'word/footer1.xml','word/footer2.xml','word/footer3.xml'
          ];

          for (const path of headerFooterPaths) {
            const fileRef = zip.file(path);
            if (!fileRef) {
              continue;
            }
            const xmlContent = await fileRef.async('string');
            const stripped = xmlContent
              .replace(/<[^>]+>/g, ' ')
              .replace(/&amp;/g, '&')
              .replace(/&lt;/g, '<')
              .replace(/&gt;/g, '>');
            if (stripped.trim()) {
              combinedText += `\n${stripped.trim()}`;
            }
          }
        } catch (zipError) {
          console.warn('DOCX header/footer extraction failed:', zipError);
        }
      }

      return combinedText.trim();
    }

    async function analyzeResume() {
      if (!resumeData) {
        alert('Please upload a resume or paste resume text first.');
        return;
      }

      // Check budget limit (hidden tracking)
      if (!checkBudgetLimit()) {
        const usage = getUsageData();
        alert(`üí∞ Monthly analysis limit reached!\n\nPlease try again next month. This protects against unexpected usage costs.`);
        return;
      }

      // Get job description inputs (optional)
      const jobDescriptionTextArea = document.getElementById('jobDescriptionText');
      const jobDescriptionLinkInput = document.getElementById('jobDescriptionLink');
      const jobDescriptionText = jobDescriptionTextArea ? jobDescriptionTextArea.value.trim() : '';
      const jobDescriptionLink = jobDescriptionLinkInput ? jobDescriptionLinkInput.value.trim() : '';
      const jobDescriptionPayload = jobDescriptionText || jobDescriptionLink;
      const autoSource = jobDescriptionTextArea?.dataset?.autofillSource || '';
      const jobInputSource = jobDescriptionText
        ? (autoSource === 'link' ? 'link' : 'text')
        : (jobDescriptionLink ? 'link' : 'none');
      if (jobInputSource === 'link' && !jobDescriptionText) {
        setJobLinkStatus('Fetching job posting details...', 'info');
      } else {
        setJobLinkStatus();
      }

      // Show analyzing state
      const analyzeBtn = document.getElementById('analyzeBtn');
      analyzeBtn.textContent = jobDescriptionPayload ? 
        'üîÑ Analyzing Resume vs Job Description...' : 
        'üîÑ Analyzing Resume...';
      analyzeBtn.disabled = true;

      try {
        const analysisPayload = await performAIResumeAnalysis(resumeData.content, jobDescriptionPayload);
        const {
          analysis,
          jobMatched,
          jobDescriptionResolved,
          jobDescriptionError,
          jobDescriptionSource
        } = analysisPayload;
        const resolvedJobDescriptionText = jobDescriptionResolved && jobDescriptionResolved.trim().length
          ? jobDescriptionResolved
          : jobDescriptionText;
        const jobContextSource = resolvedJobDescriptionText || jobDescriptionText || '';
        
        // Update usage tracking (hidden)
        updateUsageData();

        const resumeTextSnapshot = resumeData?.content || '';
        const completeness = evaluateResumeCompleteness(resumeTextSnapshot);
        analysis.completenessScore = completeness;
        analysis.extraInsights = Array.isArray(analysis.extraInsights) ? [...analysis.extraInsights] : [];
        const hasExistingCompletenessInsight = analysis.extraInsights
          .some(insight => (insight?.title || '').toLowerCase() === 'resume completeness');

        if (completeness.penalty > 0) {
          const adjustedScore = Math.max(25, Math.round((Number(analysis.overallScore) || 0) - completeness.penalty));
          analysis.overallScore = adjustedScore;
          if (!hasExistingCompletenessInsight) {
            analysis.extraInsights.unshift({
              title: 'Resume Completeness',
              status: completeness.penalty >= 25 ? 'critical' : 'warning',
              details: 'Detected missing fundamentals (length, contact info, standard headings, or bullets).',
              tips: completeness.tips
            });
          }
        }

        if (!Array.isArray(analysis.criticalKeywords) || !analysis.criticalKeywords.length) {
          analysis.criticalKeywords = generateClientCriticalKeywords(jobContextSource, resumeTextSnapshot);
        } else if (analysis.criticalKeywords.length < 15) {
          const supplements = generateClientCriticalKeywords(jobContextSource, resumeTextSnapshot);
          supplements.forEach(keyword => {
            if (analysis.criticalKeywords.length < 15 && !analysis.criticalKeywords.includes(keyword)) {
              analysis.criticalKeywords.push(keyword);
            }
          });
        }
        
        if (!jobMatched) {
          scrubJobSpecificAdvice(analysis);
        }

        handleJobLinkStatusFeedback({
          jobInputSource,
          jobDescriptionError,
          jobDescriptionSource,
          jobMatched
        });

        displayAnalysisResults(analysis, Boolean(jobMatched), resolvedJobDescriptionText || '');
        
        // Scroll to results
        document.getElementById('feedbackSection').scrollIntoView({ behavior: 'smooth' });
      } catch (error) {
        console.error('Analysis error details:', error);
        
        let errorMessage = 'Error analyzing resume: ' + error.message;
        
        // Provide more specific error messages
        if (error.message.includes('Failed to fetch')) {
          errorMessage = 'Unable to connect to the analysis service. This could be due to:\n\n' +
                       '‚Ä¢ Network connectivity issues\n' +
                       '‚Ä¢ The backend service being temporarily unavailable\n' +
                       '‚Ä¢ CORS or firewall restrictions\n\n' +
                       'A mock analysis will be shown for testing purposes.';
        } else if (error.message.includes('parse')) {
          errorMessage = 'The server response could not be processed:\n\n' + error.message + 
                       '\n\nPlease check the browser console for more details.';
        }
        
        alert(errorMessage + '\n\nNo usage counted for failed attempts.');
      } finally {
        analyzeBtn.textContent = 'üîç Analyze My Resume';
        analyzeBtn.disabled = false;
      }
    }

    async function performAIResumeAnalysis(resumeText, jobDescription = '') {
      try {
        console.log('=== ANALYSIS DEBUG INFO ===');
        console.log('Backend URL:', CONFIG.BACKEND_URL);
        console.log('Resume text length:', resumeText.length);
        console.log('Resume text preview:', resumeText.substring(0, 200) + '...');
        console.log('Job description length:', jobDescription.length);
        
        const requestBody = {
          resumeText: resumeText,
          jobDescription: jobDescription
        };
        
        console.log('Request body:', JSON.stringify(requestBody, null, 2));
        
        const response = await fetch(CONFIG.BACKEND_URL, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(requestBody)
        });

        console.log('Response status:', response.status);
        console.log('Response statusText:', response.statusText);
        console.log('Response headers:', [...response.headers.entries()]);

        const responseText = await response.text();
        console.log('Raw response text:', responseText);

        if (!response.ok) {
          let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
          try {
            const errorData = JSON.parse(responseText);
            console.log('Parsed error data:', errorData);
            errorMessage = errorData.message || errorMessage;
          } catch (e) {
            console.log('Could not parse error response as JSON:', e);
            errorMessage = responseText || errorMessage;
          }
          
          // If it's the "Failed to parse AI analysis results" error, provide a workaround
          if (errorMessage.includes('Failed to parse AI analysis results')) {
            console.log('Backend AI parsing failed, using mock response for demonstration...');
            return useDemoFallback('Backend AI parsing failed.');
          }
          
          throw new Error(`Backend Error: ${errorMessage}`);
        }
        
        let data;
        try {
          data = JSON.parse(responseText);
          console.log('Successfully parsed response:', data);
        } catch (parseError) {
          console.error('JSON parse error:', parseError);
          console.log('Using mock response due to parse error...');
          return useDemoFallback('Server response could not be parsed.');
        }
        
        if (!data.success) {
          console.log('Server returned success=false:', data);
          if (data.message && data.message.includes('Failed to parse AI analysis results')) {
            console.log('AI parsing failed on server, using mock response...');
            return useDemoFallback('AI parsing failed on server.');
          }
          throw new Error(`Analysis failed: ${data.message || 'Unknown error'}`);
        }

        if (!data.analysis) {
          console.log('No analysis data in response:', data);
          return buildAnalysisPayload({
            analysis: useDemoFallback('API returned no analysis payload.'),
            fallbackUsed: true,
            fallbackReason: 'missing_analysis_payload'
          });
        }

        console.log('Analysis successful:', data.analysis);
        return buildAnalysisPayload({
          analysis: data.analysis,
          jobMatched: data.jobMatched,
          jobDescriptionResolved: data.jobDescriptionResolved,
          jobDescriptionSource: data.jobDescriptionSource,
          jobDescriptionError: data.jobDescriptionError,
          jobDescriptionUrl: data.jobDescriptionUrl,
          fallbackUsed: data.fallbackUsed,
          fallbackReason: data.fallbackReason
        });
        
      } catch (error) {
        console.error('=== ANALYSIS ERROR ===');
        console.error('Error type:', error.constructor.name);
        console.error('Error message:', error.message);
        console.error('Error stack:', error.stack);
        
        // If it's a network error, provide mock response
        if (error.message.includes('Failed to fetch') || error.message.includes('network') || error.name === 'TypeError') {
          console.log('Network error detected, evaluating fallback...');
          return buildAnalysisPayload({
            analysis: useDemoFallback('Network connection to BACKEND_URL failed.'),
            fallbackUsed: true,
            fallbackReason: 'network_failure'
          });
        }
        
        throw error;
      }
    }

    // Mock response for testing when backend is unavailable
    function getMockAnalysisResponse() {
      return {
        overallScore: 78,
        categories: [
          {
            name: "Contact Information",
            score: 85,
            status: "good",
            feedback: "Contact information is complete and professional.",
            suggestions: []
          },
          {
            name: "Professional Summary",
            score: 72,
            status: "warning", 
            feedback: "Summary is present but could be more compelling.",
            suggestions: ["Add specific achievements with metrics", "Tailor summary to target role"]
          },
          {
            name: "Work Experience",
            score: 80,
            status: "good",
            feedback: "Good work experience with relevant positions.",
            suggestions: ["Add more quantified results", "Use stronger action verbs"]
          },
          {
            name: "Skills Section",
            score: 75,
            status: "warning",
            feedback: "Skills are listed but could be better organized.",
            suggestions: ["Group skills into categories", "Add proficiency levels"]
          },
          {
            name: "Education",
            score: 90,
            status: "good", 
            feedback: "Education section is well formatted.",
            suggestions: []
          }
        ],
        companyInsights: [
          {
            source: "resume",
            insight: "Mentions Fortune 100 clients, signaling enterprise credibility.",
            action: "Name the flagship client in the summary to reinforce scale."
          }
        ],
        extraInsights: [
          {
            title: "ATS Readiness",
            status: "warning",
            details: "Important role keywords are buried in lengthy bullets.",
            tips: ["Break bullets into tighter statements", "Add a keyword line under Skills"]
          },
          {
            title: "Storytelling",
            status: "warning",
            details: "Summary glosses over leadership scope even though later bullets cite team size.",
            tips: ["Mention team size and budget in opening paragraph", "Surface the most impressive metric near the top"]
          }
        ]
      };
    }

    function useDemoFallback(reason = 'LLM response unavailable.') {
      if (!CONFIG.FALLBACK_TO_MOCK_ON_FAILURE) {
        throw new Error(reason);
      }
      alert('Demo response loaded. For full functionality, integrate an LLM.\n\nDetails: ' + reason);
      return getMockAnalysisResponse();
    }

    function buildAnalysisPayload({
      analysis,
      jobMatched = false,
      jobDescriptionResolved = '',
      jobDescriptionSource = 'none',
      jobDescriptionError = null,
      jobDescriptionUrl = '',
      fallbackUsed = false,
      fallbackReason = null
    } = {}) {
      return {
        analysis: analysis || getMockAnalysisResponse(),
        jobMatched: Boolean(jobMatched),
        jobDescriptionResolved: jobDescriptionResolved || '',
        jobDescriptionSource,
        jobDescriptionError,
        jobDescriptionUrl,
        fallbackUsed: Boolean(fallbackUsed),
        fallbackReason
      };
    }

      function setJobLinkStatus(message = '', type = '') {
        const statusEl = document.getElementById('jobLinkStatus');
        if (!statusEl) {
          return;
        }
        statusEl.textContent = message || '';
        statusEl.classList.remove('success', 'error', 'info', 'pending');
        if (type) {
          statusEl.classList.add(type);
        }
      }

      function handleJobDescriptionTextareaInput(event) {
        const textarea = event.target;
        if (!textarea) {
          return;
        }
        if (!textarea.value.trim()) {
          delete textarea.dataset.autofillSource;
          delete textarea.dataset.autofillUrl;
          lastPrefetchedJobUrl = '';
          lastPrefetchedJobDescription = '';
          return;
        }
        if (textarea.dataset.autofillSource === 'link') {
          textarea.dataset.autofillSource = 'text';
          delete textarea.dataset.autofillUrl;
        }
      }

      function handleJobLinkInput(event) {
        const value = event.target.value.trim();
        if (!value) {
          setJobLinkStatus();
          clearJobDescriptionAutofillMetadata();
          return;
        }

        if (!isLikelyLinkedInJobUrl(value)) {
          setJobLinkStatus('Paste a LinkedIn job posting URL (https://www.linkedin.com/jobs/...) to auto-load the JD.', 'error');
          return;
        }

        setJobLinkStatus('LinkedIn link detected. Pulling the posting...', 'pending');
        scheduleJobLinkPrefetch(value);
      }

      function handleJobLinkBlur(event) {
        const value = event.target.value.trim();
        if (value && isLikelyLinkedInJobUrl(value)) {
          prefetchJobDescriptionFromLink(value, { force: true });
        }
      }

      function handleJobLinkPaste(event) {
        setTimeout(() => {
          const value = event.target.value.trim();
          if (value && isLikelyLinkedInJobUrl(value)) {
            prefetchJobDescriptionFromLink(value, { force: true });
          }
        }, 50);
      }

      function isLikelyLinkedInJobUrl(value = '') {
        return /linkedin\.com\/jobs/i.test(value || '');
      }

      function scheduleJobLinkPrefetch(url) {
        if (!url) {
          return;
        }
        clearTimeout(jobLinkPrefetchTimeout);
        jobLinkPrefetchTimeout = setTimeout(() => {
          prefetchJobDescriptionFromLink(url);
        }, JOB_LINK_PREFETCH_DELAY);
      }

      function clearJobDescriptionAutofillMetadata() {
        const textarea = document.getElementById('jobDescriptionText');
        if (textarea) {
          delete textarea.dataset.autofillSource;
          delete textarea.dataset.autofillUrl;
        }
        lastPrefetchedJobUrl = '';
        lastPrefetchedJobDescription = '';
      }

      function applyPrefetchedJobDescription(text, sourceUrl) {
        const textarea = document.getElementById('jobDescriptionText');
        if (!textarea || !text) {
          return;
        }
        textarea.value = text;
        textarea.dataset.autofillSource = 'link';
        textarea.dataset.autofillUrl = sourceUrl || '';
        textarea.scrollTop = 0;
        lastPrefetchedJobUrl = sourceUrl || '';
        lastPrefetchedJobDescription = text;
      }

      async function prefetchJobDescriptionFromLink(url, options = {}) {
        const trimmed = (url || '').trim();
        if (!trimmed || !isLikelyLinkedInJobUrl(trimmed)) {
          return;
        }

        clearTimeout(jobLinkPrefetchTimeout);
        jobLinkPrefetchTimeout = null;

        if (!options.force && trimmed === lastPrefetchedJobUrl && lastPrefetchedJobDescription) {
          setJobLinkStatus('LinkedIn job description already loaded.', 'success');
          return;
        }

        if (jobLinkPrefetchController) {
          jobLinkPrefetchController.abort();
        }
        jobLinkPrefetchController = new AbortController();

        setJobLinkStatus('Loading LinkedIn job posting‚Ä¶', 'pending');

        try {
          const response = await fetch(CONFIG.BACKEND_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              resumeText: '',
              jobDescription: trimmed,
              hydrateOnly: true
            }),
            signal: jobLinkPrefetchController.signal
          });

          const responseText = await response.text();
          let data = {};
          if (responseText) {
            try {
              data = JSON.parse(responseText);
            } catch (parseError) {
              console.warn('Job link prefetch parse error:', parseError);
            }
          }

          if (!response.ok) {
            const message = data?.jobDescriptionError || data?.message || response.statusText;
            throw new Error(message || 'Job description fetch failed');
          }

          if (data.jobDescriptionResolved && data.jobDescriptionResolved.trim().length) {
            const resolvedText = data.jobDescriptionResolved.trim();
            applyPrefetchedJobDescription(resolvedText, data.jobDescriptionUrl || trimmed);
            const words = resolvedText.split(/\s+/).filter(Boolean).length;
            setJobLinkStatus(`LinkedIn job description loaded (${words} words).`, 'success');
          } else {
            const reason = data.jobDescriptionError || 'No description found on that page.';
            clearJobDescriptionAutofillMetadata();
            setJobLinkStatus(`Could not load that posting (${reason}). Paste the text manually.`, 'error');
          }
        } catch (error) {
          if (error.name === 'AbortError') {
            return;
          }
          console.error('LinkedIn prefetch error:', error);
          clearJobDescriptionAutofillMetadata();
          setJobLinkStatus('LinkedIn job fetch failed. Please paste the description text instead.', 'error');
        } finally {
          jobLinkPrefetchController = null;
        }
      }

      function handleJobLinkStatusFeedback({
        jobInputSource = 'none',
        jobDescriptionError = null,
        jobDescriptionSource = 'none',
        jobMatched = false
      }) {
        if (jobInputSource !== 'link') {
          if (jobDescriptionError) {
            setJobLinkStatus(jobDescriptionError, 'error');
          } else {
            setJobLinkStatus();
          }
          return;
        }

        if (jobDescriptionError) {
          setJobLinkStatus(`Could not fetch LinkedIn job posting (${jobDescriptionError}). Please paste the description text instead.`, 'error');
          return;
        }

        if (jobMatched) {
          const successLabel = jobDescriptionSource === 'linkedin'
            ? 'LinkedIn job description pulled successfully.'
            : 'Job posting fetched successfully.';
          setJobLinkStatus(successLabel, 'success');
        } else {
          setJobLinkStatus('LinkedIn link received, but the posting text was unavailable. Please paste the description manually.', 'error');
        }
      }

    function escapeHTML(value = '') {
      return String(value).replace(/[&<>"']/g, char => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      })[char] || char);
    }

    function extractTopKeywords(text, limit = 10, options = {}) {
      if (!text || typeof text !== 'string') {
        return [];
      }

      const tokens = text
        .toLowerCase()
        .match(/\b[a-z0-9+]{2,}\b/g);

      if (!tokens) {
        return [];
      }

      const blockedTokens = options.blockedTokens instanceof Set ? options.blockedTokens : new Set();
      const processedTokens = tokens.map(token => ({
        token,
        keep: shouldKeepToken(token, blockedTokens)
      }));

      const unigramCounts = {};
      processedTokens.forEach(item => {
        if (item.keep) {
          unigramCounts[item.token] = (unigramCounts[item.token] || 0) + 1;
        }
      });

      const bigramCounts = buildPhraseCounts(processedTokens, 2);
      const trigramCounts = buildPhraseCounts(processedTokens, 3);

      const phraseEntries = [
        ...Object.entries(trigramCounts).map(([keyword, count]) => ({ keyword, count, boost: 1 })),
        ...Object.entries(bigramCounts).map(([keyword, count]) => ({ keyword, count, boost: 0 }))
      ].sort((a, b) => {
        const scoreA = a.count + a.boost;
        const scoreB = b.count + b.boost;
        return scoreB - scoreA || b.keyword.length - a.keyword.length;
      });

      const usedTokens = new Set();
      const results = [];

      phraseEntries.forEach(entry => {
        if (results.length >= limit) {
          return;
        }
        if (usedTokens.has(entry.keyword)) {
          return;
        }
        results.push({ keyword: entry.keyword, count: entry.count });
        entry.keyword.split(' ').forEach(part => usedTokens.add(part));
      });

      if (results.length < limit) {
        Object.entries(unigramCounts)
          .sort((a, b) => b[1] - a[1] || b[0].length - a[0].length)
          .some(([keyword, count]) => {
            if (results.length >= limit) {
              return true;
            }
            if (usedTokens.has(keyword)) {
              return false;
            }
            results.push({ keyword, count });
            usedTokens.add(keyword);
            return false;
          });
      }

      return results.slice(0, limit);
    }

    function shouldKeepToken(token, blockedTokens) {
      if (!token) {
        return false;
      }
      if (blockedTokens.has(token)) {
        return false;
      }
      if (KEYWORD_STOP_WORDS.has(token) || GENERIC_JOB_TERMS.has(token)) {
        return false;
      }
      const containsDigits = /\d/.test(token);
      const meetsLength = token.length >= 4 || ALLOWED_SHORT_TOKENS.has(token) || containsDigits;
      return meetsLength;
    }

    function buildPhraseCounts(processedTokens, gramSize = 2) {
      if (!Array.isArray(processedTokens) || processedTokens.length < gramSize) {
        return {};
      }

      const counts = {};
      for (let i = 0; i <= processedTokens.length - gramSize; i++) {
        const slice = processedTokens.slice(i, i + gramSize);
        if (slice.every(item => item.keep)) {
          const tokens = slice.map(item => item.token);
          if (isValuablePhrase(tokens)) {
            const phrase = tokens.join(' ');
            counts[phrase] = (counts[phrase] || 0) + 1;
          }
        }
      }
      return counts;
    }

    function isValuablePhrase(tokens = []) {
      if (!tokens.length) {
        return false;
      }
      const combinedLength = tokens.join('').length;
      return combinedLength >= 8 || tokens.some(token => /\d/.test(token) || ALLOWED_SHORT_TOKENS.has(token));
    }

    function extractSkillsSection(resumeText = '') {
      if (typeof resumeText !== 'string' || !resumeText.trim()) {
        return '';
      }

      const skillsMatch = resumeText.match(/skills\s*(?:section)?\s*(?:[:\-]|\n)([\s\S]{0,400})/i);
      if (skillsMatch && skillsMatch[0]) {
        return skillsMatch[0];
      }

      return '';
    }

    // Attempts to pull likely company names from the posting so we can suppress them as keywords.
    function findCompanyNames(text = '') {
      if (typeof text !== 'string' || !text.trim()) {
        return [];
      }

      const matches = new Set();
      const patterns = [
        /\b(?:at|with|within|join|inside|for|by)\s+([A-Z][\w&]+(?:\s+[A-Z][\w&]+){0,2})/g,
        /(?:^|\n)\s*([A-Z][\w&]+(?:\s+[A-Z][\w&]+){0,2})\s+(?:is|are)\s+(?:seeking|hiring|looking)/g,
        /\bCompany\s*[:\-]\s*([A-Z][\w&]+(?:\s+[A-Z][\w&]+){0,2})/g
      ];

      patterns.forEach(pattern => {
        let match;
        while ((match = pattern.exec(text)) !== null) {
          const name = match[1]?.trim();
          if (name) {
            matches.add(name);
          }
        }
      });

      return Array.from(matches);
    }

    // Blocks company-name tokens unless the resume explicitly lists them in the Skills section.
    function getCompanyTokenFilters(jobDescription = '', resumeText = '') {
      const companyNames = findCompanyNames(jobDescription);
      if (!companyNames.length) {
        return { blockedTokens: new Set() };
      }

      const skillsSection = extractSkillsSection(resumeText).toLowerCase();
      const blockedTokens = new Set();

      companyNames.forEach(name => {
        const normalized = name.toLowerCase();
        const tokens = normalized.split(/\s+/).filter(Boolean);
        const mentionedInSkills = skillsSection && skillsSection.includes(normalized);

        if (!mentionedInSkills) {
          tokens.forEach(token => blockedTokens.add(token));
        }
      });

      return { blockedTokens };
    }

    function getRelevantJobText(jobDescription = '') {
      if (typeof jobDescription !== 'string') {
        return '';
      }

      const cleaned = jobDescription.replace(/\r/g, '').trim();
      if (!cleaned) {
        return '';
      }

      const paragraphs = cleaned.split(/\n{2,}/);
      const relevant = paragraphs.filter(paragraph => {
        const lower = paragraph.toLowerCase();
        return JOB_SECTION_KEYWORDS.some(keyword => lower.includes(keyword));
      });

      if (relevant.length) {
        return relevant.join('\n\n');
      }

      const bulletLines = cleaned
        .split(/\n/)
        .filter(line => /^\s*[-*‚Ä¢]/.test(line.trim()));

      if (bulletLines.length >= 4) {
        return bulletLines.join('\n');
      }

      return cleaned;
    }

    function evaluateResumeCompleteness(text = '') {
      const normalized = (typeof text === 'string' ? text : '').trim();
      const words = normalized ? normalized.split(/\s+/).filter(Boolean) : [];
      const wordCount = words.length;
      const hasEmail = detectEmailAddress(normalized);
      const hasPhone = detectPhoneNumber(normalized);
      const hasSections = /(experience|summary|education|skills)/i.test(normalized);

      const tips = [];
      let penalty = 0;

      if (wordCount < 150) {
        penalty += 30;
        tips.push('Expand the resume beyond a short paragraph‚Äîaim for multiple sections with 400+ words.');
      } else if (wordCount < 250) {
        penalty += 20;
        tips.push('Add more depth across Summary, Experience, Skills, and Education.');
      }

      if (!hasEmail || !hasPhone) {
        penalty += 8;
        tips.push('Include both an email address and phone number in the header.');
      }

      if (!hasSections) {
        penalty += 10;
        tips.push('Add standard headings (Summary, Experience, Skills, Education).');
      }

      return { penalty, wordCount, hasEmail, hasPhone, hasSections, tips };
    }

    function detectEmailAddress(text = '') {
      if (!text) {
        return false;
      }
      const basePattern = /[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}/i;
      if (basePattern.test(text)) {
        return true;
      }
      // PDFs sometimes insert spaces; remove whitespace and retry
      const compact = text.replace(/\s+/g, '');
      return basePattern.test(compact);
    }

    function detectPhoneNumber(text = '') {
      if (!text) {
        return false;
      }
      const flexiblePattern = /(\+?\d[\d\s().-]{8,}\d)/g;
      const matches = text.match(flexiblePattern);
      if (!matches) {
        return false;
      }
      return matches.some(segment => {
        const digits = segment.replace(/\D/g, '');
        return digits.length >= 10 && digits.length <= 15;
      });
    }

    function generateClientCriticalKeywords(jobDescription = '', resumeText = '') {
      const source = `${jobDescription || ''}\n${resumeText || ''}`.toLowerCase();
      const keywords = [];

      CLIENT_CRITICAL_KEYWORD_LIBRARY.forEach(entry => {
        if (entry.hints.some(hint => source.includes(hint.toLowerCase()))) {
          if (!keywords.includes(entry.phrase)) {
            keywords.push(entry.phrase);
          }
        }
      });

      CLIENT_FALLBACK_CRITICAL_KEYWORDS.forEach(phrase => {
        if (keywords.length < 15 && !keywords.includes(phrase)) {
          keywords.push(phrase);
        }
      });

      return keywords.slice(0, 15);
    }

    function scrubJobSpecificAdvice(analysis) {
      if (!analysis || typeof analysis !== 'object') {
        return;
      }

      const renamePattern = /(job|match|align)/i;
      const scrubText = value => {
        if (typeof value !== 'string') {
          return '';
        }
        let cleaned = value;
        JOB_CONTEXT_LANGUAGE_PATTERNS.forEach(pattern => {
          cleaned = cleaned.replace(pattern, 'target opportunities');
        });
        return cleaned.trim();
      };

      if (Array.isArray(analysis.categories)) {
        analysis.categories = analysis.categories.map(category => {
          if (!category || typeof category !== 'object') {
            return category;
          }

          const safeName = renamePattern.test(category.name || '') ? 'Keyword Optimization' : category.name;
          const cleanedSuggestions = Array.isArray(category.suggestions)
            ? category.suggestions.map(scrubText).filter(Boolean)
            : [];
          const suggestionFallback = 'Highlight measurable wins and ATS-friendly keywords relevant to your target opportunities.';

          return {
            ...category,
            name: safeName,
            feedback: scrubText(category.feedback) || category.feedback,
            scoreExplanation: scrubText(category.scoreExplanation) || category.scoreExplanation,
            suggestions: cleanedSuggestions.length ? cleanedSuggestions : [suggestionFallback]
          };
        });
      }

      if (Array.isArray(analysis.extraInsights)) {
        analysis.extraInsights = analysis.extraInsights.map(insight => {
          if (!insight || typeof insight !== 'object') {
            return insight;
          }

          const cleanedTips = Array.isArray(insight.tips)
            ? insight.tips.map(scrubText).filter(Boolean)
            : [];
          const cleanedDetails = scrubText(insight.details) || insight.details || 'Focus on quantifiable wins and ATS-friendly phrasing.';
          const tipsFallback = 'Keep emphasizing impact-focused bullets so target opportunities feel like a clear fit.';

          return {
            ...insight,
            details: cleanedDetails,
            tips: cleanedTips.length ? cleanedTips : [tipsFallback]
          };
        });
      }
    }

    function displayAnalysisResults(analysis, hasJobDescription = false, jobDescriptionText = '') {
      analysisResults = analysis;
      
      const feedbackContent = document.getElementById('feedbackContent');
      const safeScore = Math.max(0, Math.min(100, Number(analysis.overallScore) || 0));
      const categories = Array.isArray(analysis.categories) ? analysis.categories : [];
      
      let html = `
        <div class="overall-score-card">
          <h3 class="overall-score-title">Overall Score: ${safeScore}/100</h3>
          ${hasJobDescription ? '<p class="job-match-indicator">‚úÖ Analyzed against job description</p>' : ''}
          <div class="score-bar">
            <div class="score-bar-fill" data-score="${safeScore}"></div>
          </div>
        </div>
      `;

      const scoreContext = renderScoreContext(analysis.completenessScore);
      if (scoreContext) {
        html += scoreContext;
      }

      html += categories.map(renderFeedbackCategory).join('');
      html += renderCompanyInsights(analysis.companyInsights);
      html += renderExtraInsights(analysis.extraInsights);

      const resumeTextSnapshot = resumeData?.content || '';
      const hasCriticalKeywords = Array.isArray(analysis.criticalKeywords) && analysis.criticalKeywords.length > 0;

      if (hasCriticalKeywords) {
        html += renderCriticalATSKeywords(analysis.criticalKeywords, resumeTextSnapshot);
      } else if (hasJobDescription && jobDescriptionText.trim().length > 0) {
        html += renderKeywordHighlights(jobDescriptionText, resumeTextSnapshot);
      }

      feedbackContent.innerHTML = html;
      animateScoreBars(feedbackContent);
      pruneEmptyInsightSections(feedbackContent);
      initAnalysisCollapsibles(feedbackContent);
      document.getElementById('feedbackSection').classList.add('show');
      document.getElementById('downloadSection').classList.add('show');

      renderInterviewStoryBuilder(analysis, resumeTextSnapshot, jobDescriptionText);

    }

    function renderFeedbackCategory(category) {
      const safeStatus = ['good', 'warning', 'critical'].includes(category.status) ? category.status : 'warning';
      const suggestions = Array.isArray(category.suggestions) ? category.suggestions : [];
      const safeName = category.name || category.title || category.section || category.category || category.label || 'Category';
      const safeScore = typeof category.score === 'number' ? category.score : '‚Äî';
      const scoreExplanation = typeof category.scoreExplanation === 'string' ? category.scoreExplanation : '';
      const positiveExamples = Array.isArray(category.positiveExamples)
        ? category.positiveExamples.filter(example => typeof example === 'string' && example.trim().length > 0)
        : [];

      const normalizedSuggestions = suggestions
        .map(suggestion => (typeof suggestion === 'string' ? suggestion.trim() : ''))
        .filter(Boolean)
        .filter((value, index, arr) => arr.findIndex(other => other.toLowerCase() === value.toLowerCase()) === index);

      let suggestionList = normalizedSuggestions.slice();
      const metricsCount = Number(analysisResults?.atsSignals?.metricsCount) || 0;
      if (metricsCount >= 10) {
        suggestionList = suggestionList.filter(item => !/\bmetric|quantif/i.test(item));
      }

      const cleanedFeedback = typeof category.feedback === 'string' ? category.feedback.trim() : '';
      const showScoreExplanation = Boolean(scoreExplanation) && scoreExplanation.trim() && scoreExplanation.trim().toLowerCase() !== cleanedFeedback.toLowerCase();

      const dedupedPositiveExamples = positiveExamples.filter((value, index, arr) => arr.findIndex(other => other.toLowerCase() === value.toLowerCase()) === index);

      return `
        <div class="feedback-category ${safeStatus}">
          <h3>
            <span class="status-icon ${safeStatus}"></span>
            ${safeName} (${safeScore}/100)
          </h3>
          <p class="category-feedback">${cleanedFeedback || 'Analysis unavailable for this section.'}</p>
          ${showScoreExplanation ? `<p class="score-explanation">${scoreExplanation}</p>` : ''}
          ${dedupedPositiveExamples.length ? `
            <div class="positive-examples">
              <strong>What recruiters will like:</strong>
              <ul>
                ${dedupedPositiveExamples.map(example => `<li>${example}</li>`).join('')}
              </ul>
            </div>
          ` : ''}
          ${suggestionList.length ? `
            <div>
              <strong>Suggestions for improvement:</strong>
              <ul class="suggestions-list">
                ${suggestionList.map(suggestion => `<li>${suggestion}</li>`).join('')}
              </ul>
            </div>
          ` : ''}
        </div>
      `;
    }

    function renderCompanyInsights(insights = []) {
      if (!Array.isArray(insights) || insights.length === 0) {
        return '';
      }

      const cleanedInsights = insights
        .map(item => {
          if (typeof item === 'string') {
            return {
              source: 'resume',
              insight: item.trim(),
              action: '',
              link: ''
            };
          }

          if (!item || typeof item !== 'object') {
            return { source: 'resume', insight: '', action: '', link: '' };
          }

          const rawInsight = item.insight || item.summary || item.details || item.text || '';
          const rawAction = item.action || item.recommendation || '';
          const rawLink = item.link || item.url || item.sourceLink || '';

          return {
            source: item.source || 'resume',
            insight: String(rawInsight || '').trim(),
            action: String(rawAction || '').trim(),
            link: String(rawLink || '').trim()
          };
        })
        .filter(item => item.insight.length > 0 || item.action.length > 0 || item.link.length > 0);

      if (cleanedInsights.length === 0) {
        return '';
      }

      const insightCards = cleanedInsights.map(insight => {
        const linkLabel = insight.link ? formatInsightLinkLabel(insight.link, insight.source) : '';
        return `
          <div class="company-insight-card">
            <span class="insight-pill">${formatInsightSource(insight.source, insight.link)}</span>
            <p>${insight.insight || 'Company insight unavailable.'}</p>
            ${insight.action ? `<p class="insight-action"><strong>Action:</strong> ${insight.action}</p>` : ''}
            ${insight.link ? `<a class="insight-link" href="${insight.link}" target="_blank" rel="noopener">Source: ${linkLabel}</a>` : ''}
          </div>
        `;
      }).join('');

      const bodyId = 'companyInsightsBody';
      return `
        <section class="company-insights collapsible-panel" data-collapsible-section>
          <button class="collapsible-panel-toggle" type="button" aria-expanded="false" aria-controls="${bodyId}">
            <span class="collapsible-panel-title">Company & Industry Intel</span>
            <span class="collapsible-panel-icon" aria-hidden="true">‚ñæ</span>
          </button>
          <div class="collapsible-panel-body" id="${bodyId}" hidden>
            ${insightCards}
          </div>
        </section>
      `;
    }

    function renderExtraInsights(extraInsights = []) {
      if (!Array.isArray(extraInsights) || extraInsights.length === 0) {
        return '';
      }

      const cleanedExtras = extraInsights
        .map(item => ({
          title: (item?.title || '').trim(),
          status: item?.status,
          details: (item?.details || '').trim(),
          tips: Array.isArray(item?.tips) ? item.tips.filter(tip => typeof tip === 'string' && tip.trim().length > 0) : []
        }))
        .filter(item => item.title.length > 0 || item.details.length > 0 || item.tips.length > 0);

      if (cleanedExtras.length === 0) {
        return '';
      }

      const statusLabelMap = {
        good: 'Momentum insight',
        warning: 'Focus opportunity',
        critical: 'Priority opportunity'
      };

      const cards = cleanedExtras.map(insight => {
        const safeStatus = ['good', 'warning', 'critical'].includes(insight.status) ? insight.status : 'warning';
        const statusLabel = statusLabelMap[safeStatus] || 'Insight focus';
        const tipsList = insight.tips.length
          ? `<ul>${insight.tips.map(tip => `<li>${tip}</li>`).join('')}</ul>`
          : '';

        return `
          <div class="extra-insight-card status-${safeStatus}">
            <div class="extra-insight-header">
              <h4>${insight.title || 'Additional Insight'}</h4>
              <span class="status-dot ${safeStatus}" title="${statusLabel}" aria-label="${statusLabel}"></span>
            </div>
            <p>${insight.details || 'No additional details provided.'}</p>
            ${tipsList}
          </div>
        `;
      }).join('');

      const bodyId = 'extraInsightsBody';
      return `
        <section class="extra-insights collapsible-panel" data-collapsible-section>
          <button class="collapsible-panel-toggle" type="button" aria-expanded="false" aria-controls="${bodyId}">
            <span class="collapsible-panel-title">Additional Insight Themes</span>
            <span class="collapsible-panel-icon" aria-hidden="true">‚ñæ</span>
          </button>
          <div class="collapsible-panel-body" id="${bodyId}" hidden>
            ${cards}
          </div>
        </section>
      `;
    }

    function renderCriticalATSKeywords(criticalKeywords = [], resumeText = '') {
      if (!Array.isArray(criticalKeywords) || criticalKeywords.length === 0) {
        return '';
      }

      const normalizedResume = (resumeText || '').toLowerCase();
      let matchCount = 0;
      let missingCount = 0;

      const keywordItems = criticalKeywords.slice(0, 15).map(keyword => {
        if (typeof keyword !== 'string' || !keyword.trim()) {
          return '';
        }
        const safeKeyword = keyword.trim();
        const inResume = normalizedResume.includes(safeKeyword.toLowerCase());
        const statusClass = inResume ? 'match' : 'missing';
        const statusLabel = inResume ? 'Found in resume' : 'Consider adding';
        if (inResume) {
          matchCount += 1;
        } else {
          missingCount += 1;
        }

        return `
          <li class="keyword-item ${statusClass}" aria-label="${statusLabel}: ${escapeHTML(safeKeyword)}">
            <span class="keyword-pill">${escapeHTML(safeKeyword)}</span>
          </li>
        `;
      }).filter(Boolean).join('');

      if (!keywordItems) {
        return '';
      }

      const legend = `
        <div class="keyword-legend">
          <span class="legend-item match">Found in resume (${matchCount})</span>
          <span class="legend-item missing">Consider adding (${missingCount})</span>
        </div>
      `;

      const bodyId = 'criticalAtsKeywordsBody';

      return `
        <section class="keyword-section collapsible-panel" id="criticalAtsKeywords" data-collapsible-section>
          <button class="collapsible-panel-toggle" type="button" aria-expanded="false" aria-controls="${bodyId}">
            <span class="collapsible-panel-title">Top 15 ATS Critical Keywords</span>
            <span class="collapsible-panel-icon" aria-hidden="true">‚ñæ</span>
          </button>
          <div class="collapsible-panel-body" id="${bodyId}" hidden>
            <p>LLM-ranked phrases recruiters scan for first. Missing phrases are prime additions for your summary, skills, or bullets.</p>
            ${legend}
            <ul class="keyword-list">
              ${keywordItems}
            </ul>
          </div>
        </section>
      `;
    }

    function renderKeywordHighlights(jobDescriptionText, resumeText = '') {
      const { blockedTokens } = getCompanyTokenFilters(jobDescriptionText, resumeText);
      const relevantJobText = getRelevantJobText(jobDescriptionText);
      const sourceText = relevantJobText || jobDescriptionText;
      const keywordData = extractTopKeywords(sourceText, 10, { blockedTokens });

      if (!keywordData.length) {
        return '';
      }

      const normalizedResume = (resumeText || '').toLowerCase();

      let matchCount = 0;
      let missingCount = 0;

      const keywordItems = keywordData.map(({ keyword, count }) => {
        const normalizedKeyword = keyword.toLowerCase();
        const inResume = normalizedResume.includes(normalizedKeyword);
        const statusClass = inResume ? 'match' : 'missing';
        const statusLabel = inResume ? 'Found in resume' : 'Consider adding';
        if (inResume) {
          matchCount += 1;
        } else {
          missingCount += 1;
        }

        return `
          <li class="keyword-item ${statusClass}" aria-label="${statusLabel}: ${escapeHTML(keyword)}">
            <span class="keyword-pill">${escapeHTML(keyword)}</span>
            <span class="keyword-count">${count} mention${count === 1 ? '' : 's'} in job description</span>
          </li>
        `;
      }).join('');

      const legend = `
        <div class="keyword-legend">
          <span class="legend-item match">Found in resume (${matchCount})</span>
          <span class="legend-item missing">Consider adding (${missingCount})</span>
        </div>
      `;

      const bodyId = 'jobKeywordHighlightsBody';

      return `
        <section class="keyword-section collapsible-panel" id="jobKeywordHighlights" data-collapsible-section>
          <button class="collapsible-panel-toggle" type="button" aria-expanded="false" aria-controls="${bodyId}">
            <span class="collapsible-panel-title">Top Job Description Keywords</span>
            <span class="collapsible-panel-icon" aria-hidden="true">‚ñæ</span>
          </button>
          <div class="collapsible-panel-body" id="${bodyId}" hidden>
            <p>Prioritize these terms to stay aligned with the posted role. Missing keywords are strong candidates for your summary and skills section.</p>
            ${legend}
            <ul class="keyword-list">
              ${keywordItems}
            </ul>
          </div>
        </section>
      `;
    }

    function renderInterviewStoryBuilder(analysis, resumeText = '', jobDescriptionText = '') {
      const section = document.getElementById('storyBuilderSection');
      if (!section) {
        return;
      }

      const storyPanel = section.querySelector('.story-builder-panel');
      const panelBody = storyPanel?.querySelector('.collapsible-panel-body');
      const panelToggle = storyPanel?.querySelector('.collapsible-panel-toggle');
      if (panelBody) {
        panelBody.hidden = true;
      }
      if (panelToggle) {
        panelToggle.setAttribute('aria-expanded', 'false');
      }

      const starStoryContainer = document.getElementById('star-stories-container');
      const tellMeStory = document.getElementById('tellMeStory');
      const strengthPills = document.getElementById('strengthPills');
      const weaknessPlan = document.getElementById('weaknessPlan');
      const elevatorPitch = document.getElementById('elevatorPitch');

      const storyBuilder = analysis?.storyBuilder || null;

      const desiredStarCount = 4;
      const resumeDrivenStars = buildStarStories(analysis, resumeText) || [];
      const backendStars = normalizeStoryArray(storyBuilder?.starStories, desiredStarCount);
      const starStories = [];

      const appendStory = story => {
        if (!story || starStories.length >= desiredStarCount) {
          return;
        }
        if (typeof story === 'string' && story.trim().length) {
          const trimmed = story.trim();
          if (!starStories.includes(trimmed)) {
            starStories.push(trimmed);
          }
        }
      };

      backendStars.forEach(appendStory);
      resumeDrivenStars.forEach(appendStory);

      if (starStories.length < desiredStarCount) {
        const categoryFallbacks = buildStarStoriesFromCategories(analysis) || [];
        categoryFallbacks.forEach(appendStory);
      }

      const formattedStarStories = starStories
        .map(formatStarStoryEntry)
        .filter(Boolean)
        .filter(entry => !isAdministrativeStarStory(entry));

      if (starStoryContainer) {
          starStoryContainer.innerHTML = formattedStarStories.length
            ? formattedStarStories.map(renderStarStoryCard).join('')
            : '<div class="star-story-card"><div class="star-answer">Add another quantified bullet so we can auto-build STAR prompts.</div></div>';
      }

      const tellMeFromBackend = typeof storyBuilder?.tellMeIntro === 'string' ? storyBuilder.tellMeIntro.trim() : '';
      tellMeStory.textContent = tellMeFromBackend || buildTellMeStoryIntro(analysis, resumeText, jobDescriptionText);

      const backendStrengths = normalizeStoryArray(storyBuilder?.tailoredStrengths, 10);
      const strengths = backendStrengths.length ? backendStrengths : buildStrengthList(analysis);
      strengthPills.innerHTML = '';
      if (strengths.length) {
        strengths.forEach(item => {
          const pill = document.createElement('span');
          pill.className = 'story-pill';
          pill.textContent = item;
          strengthPills.appendChild(pill);
        });
      } else {
        strengthPills.innerHTML = '<p style="opacity:0.85;">Add more keywords so we can personalize this list.</p>';
      }

      const backendWeakness = formatWeaknessMitigation(storyBuilder?.weaknessMitigation);
      weaknessPlan.textContent = backendWeakness || buildWeaknessMitigation(analysis);

      const backendPitch = typeof storyBuilder?.elevatorPitch === 'string' ? storyBuilder.elevatorPitch.trim() : '';
      elevatorPitch.textContent = backendPitch || buildElevatorPitch(analysis, strengths, jobDescriptionText);

      section.style.display = 'block';
      section.classList.add('show');
      initAnalysisCollapsibles(section);
    }

    function normalizeStoryArray(entries, limit) {
      if (!Array.isArray(entries) || entries.length === 0) {
        return [];
      }
      return entries
        .map(entry => {
          if (typeof entry === 'string') {
            return entry.trim();
          }
          if (entry && typeof entry === 'object') {
            const parts = [entry.title, entry.story, entry.summary, entry.scenario, entry.situation, entry.action, entry.result]
              .map(part => (typeof part === 'string' ? part.trim() : ''))
              .filter(Boolean);
            return parts.join(' ‚Äî ').trim();
          }
          return '';
        })
        .filter(Boolean)
        .slice(0, limit);
    }

    function formatStarStoryEntry(entry) {
      if (!entry) {
        return null;
      }

      const raw = typeof entry === 'string' ? entry.trim() : '';
      if (!raw) {
        return null;
      }

      const normalized = raw
        .replace(/\|\|/g, '\n')
        .replace(/\r\n|\r/g, '\n');
      const sections = extractStarSections(normalized);
      if (!sections.situation || !sections.task || !sections.action || !sections.result) {
        const parentheticalSections = extractParentheticalStarSections(normalized);
        ['situation','task','action','result'].forEach(label => {
          if (!sections[label] && parentheticalSections[label]) {
            sections[label] = parentheticalSections[label];
          }
        });
      }
      const defaultQuestion = 'Tell me about a time you led an impactful project.';
      const question = sanitizeStarQuestion(sections.question || normalized.split(/situation\s*[:-]/i)[0] || defaultQuestion);
      const answerRaw = sections['sample answer'] || sections.answer || sections.response || buildSampleAnswerFromSections(sections);
      const answer = answerRaw ? answerRaw.replace(/\|\|/g, ' ').trim() : '';
      const clean = value => (value || '').replace(/\|\|/g, ' ').trim();

      return {
        question: question || defaultQuestion,
        situation: clean(sections.situation),
        task: clean(sections.task),
        action: clean(sections.action),
        result: clean(sections.result),
        answer: answer || '',
        rawStory: normalized.trim()
      };
    }

    function isAdministrativeStarStory(entry) {
      const text = [entry.question, entry.situation, entry.task, entry.action, entry.result, entry.answer]
        .filter(Boolean)
        .join(' ')
        .toLowerCase();

      if (!text) {
        return false;
      }

      const contactSignal = /(contact info|contact information|email address|phone number|mailing address|linkedin profile)/i;
      const formattingSignal = /(resume (?:format|layout|template)|bullet points|skills section|header section|section formatting)/i;
      
      // Detect resume category feedback disguised as STAR stories
      // These typically start with a resume section name followed by "Situation ‚Äî" and contain feedback patterns
      const resumeSectionFeedback = /^(work experience|professional summary|contact information|education|skills|certifications?|experience|header|objective)\s*[:\-]/i;
      const sectionDetectedPattern = /(section detected|detected\.|section contains|ensure it|make sure|add (?:\d+(?:[-\s]\d+)?\s*)?(quantified|clear|more)|keep the|near the|recruiters can)/i;
      
      // Check if the question looks like resume section feedback
      const questionText = (entry.question || '').trim();
      const isResumeSectionTitle = resumeSectionFeedback.test(questionText);
      const hasFeedbackPattern = sectionDetectedPattern.test(text);
      
      return contactSignal.test(text) || formattingSignal.test(text) || (isResumeSectionTitle && hasFeedbackPattern);
    }

    function extractStarSections(text = '') {
      const labels = ['question','situation','task','action','result','sample answer','answer','response'];
      const regex = /(question|situation|task|action|result|sample answer|answer|response)\s*[:\-]\s*/gi;
      const sections = {};
      let match;
      let lastLabel = null;
      let lastIndex = 0;

      while ((match = regex.exec(text)) !== null) {
        if (lastLabel) {
          sections[lastLabel] = text.slice(lastIndex, match.index).trim();
        } else if (text.slice(0, match.index).trim() && !sections.preface) {
          sections.preface = text.slice(0, match.index).trim();
        }
        lastLabel = match[1].toLowerCase();
        lastIndex = regex.lastIndex;
      }

      if (lastLabel) {
        sections[lastLabel] = text.slice(lastIndex).trim();
      }

      if (!sections.question && sections.preface) {
        sections.question = sections.preface;
      }

      return sections;
    }

    function extractParentheticalStarSections(text = '') {
      if (!text || !text.includes('(')) {
        return {};
      }

      const sections = {};
      const cleanup = value => value
        .replace(/^[\s,;:‚Äî‚Äì-]+/, '')
        .replace(/[\s,;:‚Äî‚Äì-]+$/g, '')
        .trim();

      const regex = /\((Situation|Task|Action|Result)\)/gi;
      let match;
      let lastIndex = 0;

      while ((match = regex.exec(text)) !== null) {
        const label = match[1].toLowerCase();
        if (sections[label]) {
          lastIndex = match.index + match[0].length;
          continue;
        }
        const clause = cleanup(text.slice(lastIndex, match.index));
        if (clause) {
          sections[label] = clause;
        }
        lastIndex = match.index + match[0].length;
      }

      return sections;
    }

    function sanitizeStarQuestion(text = '') {
      const cleaned = text
        .replace(/^[-‚Ä¢*‚≠ê\d.\s"']+/, '')
        .replace(/\|\|/g, ' ')
        .replace(/["']+$/g, '')
        .trim();
      if (!cleaned) {
        return '';
      }
      if (!/\?$/.test(cleaned)) {
        return cleaned.endsWith('.') ? cleaned : `${cleaned}?`;
      }
      return cleaned;
    }

    function buildSampleAnswerFromSections(sections = {}) {
      const sanitize = (value = '') => value.replace(/\|\|/g, ' ').trim();
      const parts = [];
      if (sections.situation) {
        parts.push(`Situation: ${sanitize(sections.situation)}`);
      }
      if (sections.task) {
        parts.push(`Task: ${sanitize(sections.task)}`);
      }
      if (sections.action) {
        parts.push(`Action: ${sanitize(sections.action)}`);
      }
      if (sections.result) {
        parts.push(`Result: ${sanitize(sections.result)}`);
      }
      return parts.join(' ');
    }

    function renderStarStoryCard(entry) {
      const segments = [];
      const pushSegment = (label, text) => {
        const trimmed = typeof text === 'string' ? text.replace(/\|\|/g, ' ').trim() : '';
        if (!trimmed) {
          return;
        }
        segments.push(`<span class="star-segment"><strong>${label}</strong> ${escapeHTML(trimmed)}</span>`);
      };

      pushSegment('Situation:', entry.situation);
      pushSegment('Task:', entry.task);
      pushSegment('Action:', entry.action);
      pushSegment('Result:', entry.result);

      let structuredHtml = segments.join(' ');
      if (!structuredHtml && entry.rawStory) {
        structuredHtml = buildSegmentsFromParentheticalRaw(entry.rawStory);
      }
      const backendAnswer = typeof entry.answer === 'string' ? entry.answer.replace(/\|\|/g, ' ').trim() : '';
      const rawStoryFallback = entry.rawStory ? `<span class="star-raw-story">${escapeHTML(entry.rawStory)}</span>` : '';
      const narrative = structuredHtml
        || (backendAnswer ? `<span class="star-raw-answer">${escapeHTML(backendAnswer)}</span>` : '')
        || rawStoryFallback
        || '<span class="star-empty">Add another quantified bullet so we can auto-build STAR prompts.</span>';

      return `
        <div class="star-story-card">
          <div class="star-question">${escapeHTML((entry.question || '').replace(/\|\|/g, ' ').trim())}</div>
          <div class="star-answer"><strong>Sample Answer:</strong> <span class="star-narrative">${narrative}</span></div>
        </div>
      `;
    }

    function buildSegmentsFromParentheticalRaw(raw = '') {
      if (!raw || !raw.includes('(')) {
        return '';
      }
      const segments = [];
      const regex = /([^()]+)\((Situation|Task|Action|Result)\)/gi;
      let match;
      while ((match = regex.exec(raw)) !== null) {
        const label = match[2];
        const snippet = (match[1] || '')
          .replace(/^[\s,;:‚Äî‚Äì-]+/, '')
          .replace(/[\s,;:‚Äî‚Äì-]+$/g, '')
          .trim();
        if (!snippet) {
          continue;
        }
        segments.push(`<span class="star-segment"><strong>${label}:</strong> ${escapeHTML(snippet)}</span>`);
      }
      return segments.join(' ');
    }

    function formatWeaknessMitigation(weaknessObj) {
      if (!weaknessObj || typeof weaknessObj !== 'object') {
        return '';
      }
      const weakness = typeof weaknessObj.weakness === 'string' ? weaknessObj.weakness.trim() : '';
      const mitigation = typeof weaknessObj.mitigation === 'string' ? weaknessObj.mitigation.trim() : '';
      if (weakness && mitigation) {
        return `${weakness} Mitigation: ${mitigation}`;
      }
      return weakness || mitigation || '';
    }

    function buildStarStories(analysis, resumeText = '') {
      const resumeDriven = buildStarStoriesFromResume(resumeText);
      if (resumeDriven.length) {
        return resumeDriven;
      }
      return buildStarStoriesFromCategories(analysis);
    }

    function buildStarStoriesFromResume(resumeText = '') {
      const achievements = extractResumeAchievements(resumeText).slice(0, 6);
      return achievements
        .map(createStarStoryFromAchievement)
        .filter(Boolean)
        .slice(0, 4);
    }

    function extractResumeAchievements(resumeText = '') {
      if (!resumeText) {
        return [];
      }
      const achievements = [];
      const lines = resumeText.split(/\r?\n/);
      let currentRole = '';
      const bulletPattern = new RegExp(`^(?:[-*‚Ä¢‚óè‚ó¶‚ñ™‚ñ´‚Ä£¬∑‚Äß‚óã‚óâ‚óé‚ñ∏‚ñπ‚ñ∫‚ú¶‚úß‚û§‚ûî‚û£‚û•‚ûß‚û®‚û©‚û™‚û´‚û¨‚û≠‚ûÆ‚ûØ‚û±‚û≤‚û≥‚ûµ‚û∏‚ûº‚ûΩ‚ûæ]|\d+\.)\s*(.+)`);

      lines.forEach(line => {
        const trimmed = line.trim();
        if (!trimmed) {
          return;
        }
        if (!bulletPattern.test(trimmed) && looksLikeRoleHeading(trimmed)) {
          currentRole = trimmed;
          return;
        }

        const match = trimmed.match(bulletPattern);
        if (match) {
          const text = match[1].replace(/\s+/g, ' ').trim();
          if (text.length >= 40 && text.length <= 260) {
            achievements.push({ role: currentRole, text });
          }
        }
      });

      return achievements;
    }

    function looksLikeRoleHeading(line = '') {
      if (!line || /^[-*‚Ä¢‚óè]/.test(line)) {
        return false;
      }
      if (line.length > 140) {
        return false;
      }
      if (/[|]/.test(line) && /\d{4}/.test(line)) {
        return true;
      }
      return /(vice president|director|manager|lead|leader|consultant|analyst|faculty|head|principal)/i.test(line);
    }

    function createStarStoryFromAchievement(achievement) {
      if (!achievement || !achievement.text) {
        return '';
      }

      const normalized = achievement.text.replace(/\s+/g, ' ').trim();
      if (!normalized) {
        return '';
      }

      // Extract rich context from the achievement
      const { action, result } = splitActionAndResult(normalized);
      const metrics = extractAllMetrics(normalized);
      const keyVerbs = extractKeyVerbs(normalized);
      const scope = extractScope(normalized);
      const domain = inferDomain(normalized);
      
      // Build a compelling interview question
      const question = buildRichQuestion(normalized, keyVerbs, domain);
      
      // Build detailed situation with business context
      const situation = buildRichSituation(achievement.role, normalized, domain);
      
      // Build task with clear accountability
      const task = buildRichTask(normalized, scope);
      
      // Build multiple action items
      const actionItems = buildRichActions(normalized, keyVerbs);
      
      // Build quantified results
      const resultItems = buildRichResults(normalized, metrics, result);
      
      // Build a polished sample answer
      const sampleAnswer = buildRichSampleAnswer({ situation, task, actionItems, resultItems, role: achievement.role });

      return `Question: ${question} || Situation: ${situation} || Task: ${task} || Action: ${actionItems} || Result: ${resultItems} || Sample Answer: ${sampleAnswer}`;
    }

    function extractAllMetrics(text = '') {
      const metrics = [];
      const patterns = [
        /\$[\d,]+(?:\.\d+)?(?:\s*(?:mm|million|billion|k|M|B))?/gi,
        /\d+(?:,\d+)*(?:\.\d+)?%/g,
        /\d+(?:,\d+)*\+?\s*(?:employees?|team members?|people|stakeholders?|users?|clients?|customers?)/gi,
        /\d+(?:,\d+)*\+?\s*(?:projects?|initiatives?|programs?|systems?)/gi,
        /(?:over|more than|approximately|nearly|about)\s*\d+(?:,\d+)*/gi
      ];
      patterns.forEach(pattern => {
        const matches = text.match(pattern) || [];
        metrics.push(...matches);
      });
      return [...new Set(metrics)];
    }

    function extractKeyVerbs(text = '') {
      const verbPatterns = [
        /\b(led|managed|directed|oversaw|spearheaded|drove|delivered|implemented|launched|created|built|designed|developed|established|transformed|streamlined|automated|optimized|improved|enhanced|increased|reduced|generated|partnered|coordinated|trained|mentored|coached)\b/gi
      ];
      const verbs = [];
      verbPatterns.forEach(pattern => {
        const matches = text.match(pattern) || [];
        verbs.push(...matches.map(v => v.toLowerCase()));
      });
      return [...new Set(verbs)];
    }

    function extractScope(text = '') {
      const scopeMatch = text.match(/(?:across|throughout|enterprise-wide|organization-wide|company-wide|global|regional|cross-functional|multi-team)/i);
      const teamMatch = text.match(/(\d+(?:,\d+)*\+?)\s*(?:employees?|team members?|people|stakeholders?)/i);
      if (teamMatch) {
        return { size: teamMatch[1], type: 'people' };
      }
      if (scopeMatch) {
        return { size: scopeMatch[0], type: 'scope' };
      }
      return null;
    }

    function inferDomain(text = '') {
      const domains = {
        training: /\b(train|training|learning|development|curriculum|onboard|upskill)\b/i,
        technology: /\b(system|software|platform|technology|digital|automation|sharepoint|dashboard|api|integration)\b/i,
        process: /\b(process|workflow|streamline|optimize|efficiency|operational)\b/i,
        revenue: /\b(revenue|sales|growth|ROI|profit|cost savings?|budget)\b/i,
        leadership: /\b(led|managed|team|stakeholder|cross-functional|partner|collaborate)\b/i,
        innovation: /\b(innovat|created|built|designed|developed|launched|new|pilot)\b/i,
        analytics: /\b(data|analytics|metrics|insights|reporting|dashboard|KPI)\b/i
      };
      for (const [domain, pattern] of Object.entries(domains)) {
        if (pattern.test(text)) {
          return domain;
        }
      }
      return 'impact';
    }

    function buildRichQuestion(text, verbs, domain) {
      const questionTemplates = {
        training: 'Tell me about a time you delivered a large training or rollout.',
        technology: 'Tell me about a time you implemented a new system or technology solution.',
        process: 'Tell me about a time you improved or streamlined a business process.',
        revenue: 'Tell me about a time you created revenue impact or drove cost savings.',
        leadership: 'Tell me about a time you led a cross-functional team or initiative.',
        innovation: 'Tell me about a time you created something innovative.',
        analytics: 'Tell me about a time you used data to drive business decisions.',
        impact: 'Tell me about a time you drove measurable business impact.'
      };
      
      // Try to match based on domain
      if (questionTemplates[domain]) {
        return questionTemplates[domain];
      }
      
      // Fallback to verb-based question
      if (verbs.includes('trained') || verbs.includes('coached') || verbs.includes('mentored')) {
        return 'Tell me about a time you trained or developed others.';
      }
      if (verbs.includes('led') || verbs.includes('managed') || verbs.includes('directed')) {
        return 'Tell me about a time you led a critical initiative.';
      }
      if (verbs.includes('created') || verbs.includes('built') || verbs.includes('designed')) {
        return 'Tell me about a time you built something from the ground up.';
      }
      
      return 'Tell me about a time you drove measurable change.';
    }

    function buildRichSituation(role, text, domain) {
      const roleContext = role ? `In your role${role.includes('|') ? '' : ' as ' + role.split(/[|,]/)[0].trim()},` : 'In this role,';
      
      const situationTemplates = {
        training: 'a new system release or initiative required consistent training across a large workforce.',
        technology: 'there was a need for improved technology solutions to enhance operational efficiency.',
        process: 'existing processes were creating inefficiencies or bottlenecks that needed addressing.',
        revenue: 'there was an opportunity to drive revenue growth or realize cost savings.',
        leadership: 'a complex initiative required coordination across multiple teams or stakeholders.',
        innovation: 'you noticed a gap or opportunity that could be addressed with a creative solution.',
        analytics: 'business decisions needed to be informed by better data and insights.',
        impact: 'an opportunity arose to drive significant business impact.'
      };
      
      const template = situationTemplates[domain] || situationTemplates.impact;
      return `${roleContext} ${template}`;
    }

    function buildRichTask(text, scope) {
      let accountabilityClause = 'You were responsible for';
      
      if (scope) {
        if (scope.type === 'people') {
          const numericSize = parseInt(scope.size.replace(/,/g, ''), 10);
          accountabilityClause = `You were accountable for leading this initiative, impacting ${scope.size} ${numericSize === 1 ? 'person' : 'people'}`;
        } else {
          accountabilityClause = `You were accountable for driving this ${scope.size} initiative`;
        }
      }
      
      // Extract key deliverable
      const deliverableMatch = text.match(/(?:to|for)\s+([a-z][a-z\s,]+?)(?:\.|,|;|resulting|leading|which|that|and\s+(?:drove|delivered|achieved))/i);
      if (deliverableMatch) {
        return `${accountabilityClause} ${deliverableMatch[1].trim()}, ensuring accuracy, quality, and successful adoption.`;
      }
      
      return `${accountabilityClause} delivering this initiative end-to-end while ensuring stakeholder alignment and measurable outcomes.`;
    }

    function buildRichActions(text, verbs) {
      const MAX_ACTIONS = 5;
      const MIN_ACTIONS = 3;
      const actions = [];
      
      // Map verbs to action descriptions
      const verbToAction = {
        'designed': 'Designed the solution architecture and approach',
        'built': 'Built and developed the core deliverables',
        'created': 'Created comprehensive materials and documentation',
        'developed': 'Developed the strategy and execution plan',
        'implemented': 'Implemented the solution across the organization',
        'launched': 'Launched the initiative with stakeholder buy-in',
        'led': 'Led the team and coordinated resources',
        'managed': 'Managed timelines, resources, and stakeholder expectations',
        'trained': 'Conducted training sessions and knowledge transfer',
        'coordinated': 'Coordinated with leaders and cross-functional partners',
        'partnered': 'Partnered with key stakeholders to ensure alignment',
        'streamlined': 'Streamlined processes to improve efficiency',
        'automated': 'Automated manual processes to reduce effort',
        'optimized': 'Optimized workflows for better performance',
        'established': 'Established frameworks and best practices',
        'transformed': 'Transformed existing approaches with new methods'
      };
      
      // Add actions based on verbs found
      verbs.forEach(verb => {
        if (verbToAction[verb] && actions.length < MAX_ACTIONS) {
          actions.push(verbToAction[verb]);
        }
      });
      
      // Add generic actions if we need more
      if (actions.length < MIN_ACTIONS) {
        const genericActions = [
          'Developed the execution strategy',
          'Coordinated with stakeholders for alignment',
          'Measured and tracked progress against goals',
          'Implemented feedback loops for continuous improvement'
        ];
        genericActions.forEach(action => {
          if (actions.length < MAX_ACTIONS && !actions.includes(action)) {
            actions.push(action);
          }
        });
      }
      
      return actions.join(' ‚Ä¢ ');
    }

    function buildRichResults(text, metrics, resultClause) {
      const results = [];
      
      // Add quantified metrics
      metrics.forEach(metric => {
        if (metric.includes('$')) {
          results.push(`Generated ${metric} in business value`);
        } else if (metric.includes('%')) {
          results.push(`Achieved ${metric} improvement`);
        } else {
          results.push(`Impacted ${metric}`);
        }
      });
      
      // Add qualitative results
      if (results.length < 2) {
        const qualitativeResults = [
          'Improved operational efficiency and consistency',
          'Enhanced stakeholder satisfaction and adoption',
          'Delivered measurable business impact'
        ];
        qualitativeResults.forEach(result => {
          if (results.length < 3) {
            results.push(result);
          }
        });
      }
      
      return results.join(' ‚Ä¢ ');
    }

    function buildRichSampleAnswer(parts) {
      const segments = [];
      
      // Opening with situation
      const situationOpener = parts.situation
        .replace(/^In your role.*?,/i, 'In my role,')
        .replace(/^In this role,/i, 'In this role,');
      segments.push(situationOpener);
      
      // Add accountability
      const taskStatement = parts.task
        .replace(/^You were/i, 'I was')
        .replace(/^You/i, 'I');
      segments.push(taskStatement);
      
      // Add key actions (condensed)
      const actionList = parts.actionItems.split(' ‚Ä¢ ').slice(0, 3);
      if (actionList.length) {
        const actionIntro = 'I ' + actionList[0].charAt(0).toLowerCase() + actionList[0].slice(1);
        segments.push(actionIntro + '.');
      }
      
      // Add results
      const resultList = parts.resultItems.split(' ‚Ä¢ ');
      if (resultList.length) {
        const resultStatement = resultList[0].replace(/^(Generated|Achieved|Impacted)/i, 'The outcome was');
        segments.push(resultStatement + ', and the initiative was considered a success.');
      }
      
      return segments.join(' ');
    }

    function splitActionAndResult(line = '') {
      const triggerPattern = /(resulted in|resulting in|leading to|led to|which led to|driving|drove|generated|creating|producing|delivering|delivered|achieving|achieved|boosting|increasing|reducing)\s+/i;
      const match = triggerPattern.exec(line);
      if (!match) {
        return { action: line, result: '' };
      }
      const action = line.slice(0, match.index).replace(/[;,]\s*$/, '').trim();
      const result = line.slice(match.index).trim();
      return { action, result };
    }

    function stripResultTrigger(text = '') {
      if (!text) {
        return '';
      }
      return text.replace(/^(resulted in|resulting in|leading to|led to|which led to|driving|drove|generated|creating|producing|delivering|delivered|achieving|achieved|boosting|increasing|reducing)\s+/i, '').trim();
    }

    function extractTaskClause(line = '') {
      const match = line.match(/\bto\s+([a-z0-9 ,.%$-]+?)(?:[;,\.]|$)/i);
      if (!match) {
        return '';
      }
      return match[1].trim().replace(/^(the|a|an)\s+/i, '').replace(/(?:by|via).*$/i, '').trim();
    }

    function buildSituationSentence(role = '', context = '') {
      const base = role ? `While serving as ${role},` : 'In this role,';
      const contextHint = context ? ensureLowercaseStart(context) : 'an opportunity to drive impact';
      return `${base} you recognized ${contextHint || 'an opportunity to drive impact'}.`;
    }

    function ensureLowercaseStart(text = '') {
      if (!text) {
        return '';
      }
      const trimmed = text.replace(/[.]+$/, '').trim();
      if (!trimmed) {
        return '';
      }
      return trimmed.charAt(0).toLowerCase() === trimmed.charAt(0)
        ? trimmed
        : trimmed.charAt(0).toLowerCase() + trimmed.slice(1);
    }

    function inferResultFromLine(line = '') {
      const metricMatch = line.match(/(\$?\d[\d,]*(?:\.\d+)?\s*(?:%|mm|million|bn|billion|k)?)/i);
      if (metricMatch) {
        return `Delivered ${metricMatch[0]} impact and measurable performance gains.`;
      }
      return 'Delivered measurable improvements tied to KPIs.';
    }

    function buildQuestionFromAction(actionText = '') {
      if (!actionText) {
        return 'Tell me about a time you drove measurable change.';
      }
      const cleaned = actionText.replace(/^you\s+/i, '').replace(/\.$/, '').trim();
      const verbMatch = cleaned.match(/^[a-z]+/i);
      if (!verbMatch) {
        return 'Tell me about a time you led a critical initiative.';
      }
      const verb = verbMatch[0].toLowerCase();
      const remainder = cleaned.slice(verbMatch[0].length).trim();
      const subject = remainder || 'a critical initiative';
      const question = `Tell me about a time you ${verb} ${subject}`.replace(/\s+/g, ' ').trim();
      return question.endsWith('?') ? question : `${question}?`;
    }

    function buildSampleAnswer(parts = {}) {
      const segments = [];
      if (parts.situation) {
        segments.push(parts.situation.replace(/^in this role,/i, 'In this role,'));
      }
      if (parts.task) {
        segments.push(parts.task);
      }
      if (parts.action) {
        const cleanedAction = parts.action.replace(/^You\s+/i, 'I ');
        segments.push(cleanedAction);
      }
      if (parts.result) {
        segments.push(parts.result.startsWith('Delivered') ? parts.result : `As a result, ${parts.result}`);
      }
      return segments.join(' ');
    }

    function toSentenceCase(text = '') {
      if (!text) {
        return '';
      }
      const trimmed = text.replace(/^[,;\s]+/, '').trim();
      if (!trimmed) {
        return '';
      }
      return trimmed.charAt(0).toUpperCase() + trimmed.slice(1);
    }

    function buildStarStoriesFromCategories(analysis) {
      const categories = Array.isArray(analysis?.categories) ? analysis.categories.slice(0, 3) : [];
      if (!categories.length) {
        return [];
      }
      return categories.map(category => {
        const safeName = category.name || 'Impact Area';
        const situation = category.feedback || 'Describe the context, scale, and stakeholders involved.';
        const task = `You were accountable for elevating ${safeName.toLowerCase()} performance.`;
        const action = (category.suggestions && category.suggestions[0]) || 'Explain the actions you drove end-to-end.';
        const result = (category.suggestions && category.suggestions[1]) || 'Finish with a measurable outcome, ideally quantified.';
        const question = `Tell me about a time you strengthened ${safeName.toLowerCase()}.`;
        const answer = `In that scenario, ${situation} I owned ${safeName.toLowerCase()} delivery, focused on ${action.toLowerCase()}, and the outcome was ${result.toLowerCase()}.`;
        return `Question: ${question} || Situation: ${situation} || Task: ${task} || Action: ${action} || Result: ${result} || Sample Answer: ${answer}`;
      });
    }

    function buildTellMeStoryIntro(analysis, resumeText = '', jobDescriptionText = '') {
      const keywords = Array.isArray(analysis?.criticalKeywords) ? analysis.criticalKeywords.slice(0, 2) : [];
      const highlight = analysis?.extraInsights?.find(insight => insight.status === 'good')?.details || '';
      const roleHint = (jobDescriptionText.match(/(?:manager|director|lead|analyst|specialist)/i) || [])[0] || 'leader';
      const metricCount = Number(analysis?.atsSignals?.metricsCount) || 0;
      const summaryLine = highlight || `Known for driving measurable improvements across ${keywords.join(' & ') || 'complex programs'}.`;

      return `I'm a ${roleHint.toLowerCase()} who specializes in ${keywords.join(' + ') || 'program execution'} and consistently weaves ${metricCount || 'multiple'} measurable wins into every role. ${summaryLine}`;
    }

    function buildStrengthList(analysis) {
      const pool = new Set();
      (analysis?.criticalKeywords || []).slice(0, 10).forEach(keyword => pool.add(keyword));
      (analysis?.highlightKeywords || []).slice(0, 10).forEach(keyword => pool.add(keyword));
      (analysis?.extraInsights || []).forEach(insight => {
        if (insight?.title) {
          pool.add(insight.title);
        }
      });
      return Array.from(pool).slice(0, 10);
    }

    function buildLeadershipStories(resumeText = '', analysis) {
      const leadershipRegex = /(led|managed|mentored|directed|oversaw|spearheaded|coach|mentored|partnered)/i;
      const lines = (resumeText || '')
        .split(/\r?\n/)
        .map(line => line.trim())
        .filter(line => leadershipRegex.test(line) && line.length < 220);
      if (lines.length) {
        return lines.slice(0, 3);
      }

      const categories = Array.isArray(analysis?.categories) ? analysis.categories : [];
      return categories
        .filter(category => /leadership|stakeholder|team/i.test(category.name || '') && category.feedback)
        .slice(0, 2)
        .map(category => category.feedback);
    }

    function buildWeaknessMitigation(analysis) {
      const warning = (analysis?.atsWarnings || [])[0] || 'Interviewers may test how you plan to scale your impact.';
      const mitigation = analysis?.extraInsights?.find(insight => insight.status === 'critical')?.tips?.[0]
        || 'Explain the playbook you are using to close the gap and the metric you are targeting next.';
      return `${warning} Mitigation: ${mitigation}`;
    }

    function buildElevatorPitch(analysis, strengths = [], jobDescriptionText = '') {
      const focusArea = strengths.slice(0, 3).join(', ') || 'program leadership, analytics, and stakeholder alignment';
      const keywordFromJD = (jobDescriptionText.match(/\b[A-Z][a-z]+(?: [A-Z][a-z]+)?\b/) || [])[0] || 'your team';
      const extraInsights = Array.isArray(analysis?.extraInsights) ? analysis.extraInsights : [];
      const highlights = (extraInsights[0]?.details) || 'deliver measurable improvements and crisp reporting.';
      const score = Number(analysis?.overallScore) || 75;
      return `In 90 seconds: I blend ${focusArea} to keep initiatives on track, and recent analyses peg the resume at ${score}/100 readiness. I'm targeting ${keywordFromJD} so I can ${highlights}`;
    }

    function renderScoreContext(completeness = null) {
      if (!completeness || typeof completeness.penalty !== 'number' || completeness.penalty <= 0) {
        return '';
      }

      const issues = [];
      const wordCount = Number(completeness.wordCount) || 0;
      if (wordCount && wordCount < 150) {
        issues.push(`Resume is only ${wordCount} words; expand each section to show depth (target 400+).`);
      } else if (wordCount && wordCount < 250) {
        issues.push(`Resume is ${wordCount} words; add more detail so each section demonstrates scope.`);
      }

      if (!completeness.hasEmail || !completeness.hasPhone) {
        issues.push('Include both a phone number and email address in the contact header.');
      }

      if (!completeness.hasSections) {
        issues.push('Add standard headings like Summary, Experience, Skills, and Education.');
      }

      const fallbackTips = Array.isArray(completeness.tips) ? completeness.tips : [];
      const contextList = (issues.length ? issues : fallbackTips).slice(0, 3);

      if (!contextList.length) {
        return '';
      }

      const severity = completeness.penalty >= 25 ? 'critical' : 'warning';
      const heading = completeness.penalty >= 25 ? 'Score Adjustment (Major)' : 'Score Adjustment (Minor)';

      return `
        <div class="feedback-category ${severity} score-adjustment-card ${severity}">
          <h3>
            <span class="status-icon ${severity}"></span>
            ${heading} (-${completeness.penalty} pts)
          </h3>
          <p class="category-feedback">These fundamentals pulled down your overall score before comparing category performance.</p>
          <ul class="suggestions-list">
            ${contextList.map(item => `<li>${escapeHTML(item)}</li>`).join('')}
          </ul>
        </div>
      `;
    }

    function formatInsightSource(source = 'resume', link = '') {
      const normalized = typeof source === 'string' ? source.toLowerCase().trim() : 'resume';
      const labelMap = {
        resume: 'Resume signal',
        jobdescription: 'Job description intel',
        'job description': 'Job description intel',
        public: 'Public intel',
        'public knowledge': 'Public intel'
      };
      const base = labelMap[normalized] || (source ? source : 'Insight source');
      if (link) {
        const host = formatInsightLinkLabel(link, base);
        return `${base} ‚Ä¢ ${host}`;
      }
      return base;
    }

    function formatInsightLinkLabel(link = '', fallback = 'source') {
      if (!link) {
        return fallback;
      }
      try {
        const host = new URL(link).hostname.replace(/^www\./i, '');
        return host || fallback;
      } catch (err) {
        return fallback;
      }
    }

    function animateScoreBars(root) {
      const fills = root.querySelectorAll('.score-bar-fill');
      fills.forEach(fill => {
        const score = Number(fill.dataset.score) || 0;
        requestAnimationFrame(() => {
          fill.style.width = `${score}%`;
        });
      });
    }

    function pruneEmptyInsightSections(root) {
      const companySections = root.querySelectorAll('.company-insights');
      companySections.forEach(section => {
        if (!section.querySelector('.company-insight-card')) {
          section.remove();
        }
      });

      const extraSections = root.querySelectorAll('.extra-insights');
      extraSections.forEach(section => {
        if (!section.querySelector('.extra-insight-card')) {
          section.remove();
        }
      });
    }

    function initAnalysisCollapsibles(root) {
      if (!root) {
        return;
      }

      const panels = root.querySelectorAll('.collapsible-panel');
      panels.forEach(panel => {
        const toggle = panel.querySelector('.collapsible-panel-toggle');
        const body = panel.querySelector('.collapsible-panel-body');
        if (!toggle || !body || toggle.dataset.collapseBound === 'true') {
          return;
        }

        const isOpen = panel.classList.contains('open');
        body.hidden = !isOpen;
        toggle.setAttribute('aria-expanded', String(isOpen));

        toggle.dataset.collapseBound = 'true';

        toggle.addEventListener('click', () => {
          panel.classList.toggle('open');
          const nowOpen = panel.classList.contains('open');
          body.hidden = !nowOpen;
          toggle.setAttribute('aria-expanded', String(nowOpen));
        });
      });
    }

    function initCollapsibleSections() {
      const toggles = document.querySelectorAll('.collapsible-toggle');
      toggles.forEach(toggle => {
        const targetId = toggle.dataset.target;
        const target = document.getElementById(targetId);
        const container = toggle.closest('.collapsible');
        if (!target || !container) {
          return;
        }

        toggle.setAttribute('aria-controls', targetId);
        const textarea = target.querySelector('textarea');
        const hasPrefilledValue = textarea && textarea.value.trim().length > 0;

        if (hasPrefilledValue) {
          container.classList.add('open');
          target.removeAttribute('hidden');
          toggle.setAttribute('aria-expanded', 'true');
          toggle.textContent = 'Hide Text Input';
        } else {
          container.classList.remove('open');
          target.setAttribute('hidden', '');
          toggle.setAttribute('aria-expanded', 'false');
          toggle.textContent = 'Show Text Input';
        }

        toggle.addEventListener('click', () => {
          const isOpen = container.classList.toggle('open');
          toggle.setAttribute('aria-expanded', String(isOpen));
          toggle.textContent = isOpen ? 'Hide Text Input' : 'Show Text Input';
          if (isOpen) {
            target.removeAttribute('hidden');
          } else {
            target.setAttribute('hidden', '');
          }
        });
      });
    }

    // Initialize page
    document.addEventListener('DOMContentLoaded', function() {
      initCollapsibleSections();
      console.log('Resume Analyzer page loaded');
      console.info('DEV REMINDER: Do not default new UI sections to opacity: 0 unless there is explicit reveal logic.');
    });
  </script>
</body>
</html>
